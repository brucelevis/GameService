// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: P_Asset.proto

#ifndef PROTOBUF_P_5fAsset_2eproto__INCLUDED
#define PROTOBUF_P_5fAsset_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/protobuf/descriptor.pb.h"
// @@protoc_insertion_point(includes)

namespace Adoter {
namespace Asset {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_P_5fAsset_2eproto();
void protobuf_AssignDesc_P_5fAsset_2eproto();
void protobuf_ShutdownFile_P_5fAsset_2eproto();

class Vector2;
class Vector3;
class CommonProp;
class AssetCommonProp;
class Plant;
class CommonLimit;
class CoolDown;
class Hoster;
class Harm;
class Skill;
class LevelUpCurve;
class LevelUpCurve_Consume;
class Scene;
class Particle;
class Item_CommonProp;
class Item_Item;
class Item_Potion;
class Item_Equipment;

enum CommonLimit_COMMON_LIMIT_TYPE {
  CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_PLANT = 1
};
bool CommonLimit_COMMON_LIMIT_TYPE_IsValid(int value);
const CommonLimit_COMMON_LIMIT_TYPE CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_MIN = CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_PLANT;
const CommonLimit_COMMON_LIMIT_TYPE CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_MAX = CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_PLANT;
const int CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_ARRAYSIZE = CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonLimit_COMMON_LIMIT_TYPE_descriptor();
inline const ::std::string& CommonLimit_COMMON_LIMIT_TYPE_Name(CommonLimit_COMMON_LIMIT_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonLimit_COMMON_LIMIT_TYPE_descriptor(), value);
}
inline bool CommonLimit_COMMON_LIMIT_TYPE_Parse(
    const ::std::string& name, CommonLimit_COMMON_LIMIT_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonLimit_COMMON_LIMIT_TYPE>(
    CommonLimit_COMMON_LIMIT_TYPE_descriptor(), name, value);
}
enum CommonLimit_COOL_DOWN_TYPE {
  CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_DAY = 1,
  CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_WEEK = 2,
  CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MONTH = 3,
  CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_YEAR = 4,
  CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_NEVER = 5
};
bool CommonLimit_COOL_DOWN_TYPE_IsValid(int value);
const CommonLimit_COOL_DOWN_TYPE CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MIN = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_DAY;
const CommonLimit_COOL_DOWN_TYPE CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MAX = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_NEVER;
const int CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_ARRAYSIZE = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonLimit_COOL_DOWN_TYPE_descriptor();
inline const ::std::string& CommonLimit_COOL_DOWN_TYPE_Name(CommonLimit_COOL_DOWN_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonLimit_COOL_DOWN_TYPE_descriptor(), value);
}
inline bool CommonLimit_COOL_DOWN_TYPE_Parse(
    const ::std::string& name, CommonLimit_COOL_DOWN_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonLimit_COOL_DOWN_TYPE>(
    CommonLimit_COOL_DOWN_TYPE_descriptor(), name, value);
}
enum Harm_HARM_TYPE {
  Harm_HARM_TYPE_HARM_TYPE_HP = 1,
  Harm_HARM_TYPE_HARM_TYPE_MP = 2,
  Harm_HARM_TYPE_HARM_TYPE_SPEED = 3
};
bool Harm_HARM_TYPE_IsValid(int value);
const Harm_HARM_TYPE Harm_HARM_TYPE_HARM_TYPE_MIN = Harm_HARM_TYPE_HARM_TYPE_HP;
const Harm_HARM_TYPE Harm_HARM_TYPE_HARM_TYPE_MAX = Harm_HARM_TYPE_HARM_TYPE_SPEED;
const int Harm_HARM_TYPE_HARM_TYPE_ARRAYSIZE = Harm_HARM_TYPE_HARM_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Harm_HARM_TYPE_descriptor();
inline const ::std::string& Harm_HARM_TYPE_Name(Harm_HARM_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Harm_HARM_TYPE_descriptor(), value);
}
inline bool Harm_HARM_TYPE_Parse(
    const ::std::string& name, Harm_HARM_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Harm_HARM_TYPE>(
    Harm_HARM_TYPE_descriptor(), name, value);
}
enum LevelUpCurve_Consume_CONSUME_TYPE {
  LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_EXPERIENCE = 1,
  LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_DIOMAND = 2,
  LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_TIME = 3
};
bool LevelUpCurve_Consume_CONSUME_TYPE_IsValid(int value);
const LevelUpCurve_Consume_CONSUME_TYPE LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_MIN = LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_EXPERIENCE;
const LevelUpCurve_Consume_CONSUME_TYPE LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_MAX = LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_TIME;
const int LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_ARRAYSIZE = LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* LevelUpCurve_Consume_CONSUME_TYPE_descriptor();
inline const ::std::string& LevelUpCurve_Consume_CONSUME_TYPE_Name(LevelUpCurve_Consume_CONSUME_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    LevelUpCurve_Consume_CONSUME_TYPE_descriptor(), value);
}
inline bool LevelUpCurve_Consume_CONSUME_TYPE_Parse(
    const ::std::string& name, LevelUpCurve_Consume_CONSUME_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LevelUpCurve_Consume_CONSUME_TYPE>(
    LevelUpCurve_Consume_CONSUME_TYPE_descriptor(), name, value);
}
enum Item_Potion_POTION_TYPE {
  Item_Potion_POTION_TYPE_POTION_TYPE_HEMO = 1,
  Item_Potion_POTION_TYPE_POTION_TYPE_MAGIC = 2,
  Item_Potion_POTION_TYPE_POTION_TYPE_PHYSICAL_STRENGTH = 3
};
bool Item_Potion_POTION_TYPE_IsValid(int value);
const Item_Potion_POTION_TYPE Item_Potion_POTION_TYPE_POTION_TYPE_MIN = Item_Potion_POTION_TYPE_POTION_TYPE_HEMO;
const Item_Potion_POTION_TYPE Item_Potion_POTION_TYPE_POTION_TYPE_MAX = Item_Potion_POTION_TYPE_POTION_TYPE_PHYSICAL_STRENGTH;
const int Item_Potion_POTION_TYPE_POTION_TYPE_ARRAYSIZE = Item_Potion_POTION_TYPE_POTION_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Item_Potion_POTION_TYPE_descriptor();
inline const ::std::string& Item_Potion_POTION_TYPE_Name(Item_Potion_POTION_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Item_Potion_POTION_TYPE_descriptor(), value);
}
inline bool Item_Potion_POTION_TYPE_Parse(
    const ::std::string& name, Item_Potion_POTION_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Item_Potion_POTION_TYPE>(
    Item_Potion_POTION_TYPE_descriptor(), name, value);
}
enum Item_Equipment_EQUIP_TYPE {
  Item_Equipment_EQUIP_TYPE_EQUIP_TYPE_HELMET = 1
};
bool Item_Equipment_EQUIP_TYPE_IsValid(int value);
const Item_Equipment_EQUIP_TYPE Item_Equipment_EQUIP_TYPE_EQUIP_TYPE_MIN = Item_Equipment_EQUIP_TYPE_EQUIP_TYPE_HELMET;
const Item_Equipment_EQUIP_TYPE Item_Equipment_EQUIP_TYPE_EQUIP_TYPE_MAX = Item_Equipment_EQUIP_TYPE_EQUIP_TYPE_HELMET;
const int Item_Equipment_EQUIP_TYPE_EQUIP_TYPE_ARRAYSIZE = Item_Equipment_EQUIP_TYPE_EQUIP_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Item_Equipment_EQUIP_TYPE_descriptor();
inline const ::std::string& Item_Equipment_EQUIP_TYPE_Name(Item_Equipment_EQUIP_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Item_Equipment_EQUIP_TYPE_descriptor(), value);
}
inline bool Item_Equipment_EQUIP_TYPE_Parse(
    const ::std::string& name, Item_Equipment_EQUIP_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Item_Equipment_EQUIP_TYPE>(
    Item_Equipment_EQUIP_TYPE_descriptor(), name, value);
}
enum PROF_TYPE {
  PROF_TYPE_FARMER = 1,
  PROF_TYPE_FARMER_HOSTER = 2,
  PROF_TYPE_FARMER_AND_HOSTER = 3,
  PROF_TYPE_COWBOY = 4,
  PROF_TYPE_BOUNTY_HUNTER = 16
};
bool PROF_TYPE_IsValid(int value);
const PROF_TYPE PROF_TYPE_MIN = PROF_TYPE_FARMER;
const PROF_TYPE PROF_TYPE_MAX = PROF_TYPE_BOUNTY_HUNTER;
const int PROF_TYPE_ARRAYSIZE = PROF_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* PROF_TYPE_descriptor();
inline const ::std::string& PROF_TYPE_Name(PROF_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    PROF_TYPE_descriptor(), value);
}
inline bool PROF_TYPE_Parse(
    const ::std::string& name, PROF_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PROF_TYPE>(
    PROF_TYPE_descriptor(), name, value);
}
enum INVENTORY_TYPE {
  INVENTORY_TYPE_BACKPACKAGE = 1,
  INVENTORY_TYPE_EQUIPMENT = 2,
  INVENTORY_TYPE_FASHION = 3,
  INVENTORY_TYPE_COUNT = 4
};
bool INVENTORY_TYPE_IsValid(int value);
const INVENTORY_TYPE INVENTORY_TYPE_MIN = INVENTORY_TYPE_BACKPACKAGE;
const INVENTORY_TYPE INVENTORY_TYPE_MAX = INVENTORY_TYPE_COUNT;
const int INVENTORY_TYPE_ARRAYSIZE = INVENTORY_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* INVENTORY_TYPE_descriptor();
inline const ::std::string& INVENTORY_TYPE_Name(INVENTORY_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    INVENTORY_TYPE_descriptor(), value);
}
inline bool INVENTORY_TYPE_Parse(
    const ::std::string& name, INVENTORY_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<INVENTORY_TYPE>(
    INVENTORY_TYPE_descriptor(), name, value);
}
enum ENTITY_TYPE {
  ENTITY_TYPE_NIL = 1,
  ENTITY_TYPE_PLAYER = 2,
  ENTITY_TYPE_HOST = 3,
  ENTITY_TYPE_NPC = 4,
  ENTITY_TYPE_BUILDING = 5,
  ENTITY_TYPE_SEA = 6,
  ENTITY_TYPE_AIR = 7,
  ENTITY_TYPE_LAND = 8
};
bool ENTITY_TYPE_IsValid(int value);
const ENTITY_TYPE ENTITY_TYPE_MIN = ENTITY_TYPE_NIL;
const ENTITY_TYPE ENTITY_TYPE_MAX = ENTITY_TYPE_LAND;
const int ENTITY_TYPE_ARRAYSIZE = ENTITY_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ENTITY_TYPE_descriptor();
inline const ::std::string& ENTITY_TYPE_Name(ENTITY_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ENTITY_TYPE_descriptor(), value);
}
inline bool ENTITY_TYPE_Parse(
    const ::std::string& name, ENTITY_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ENTITY_TYPE>(
    ENTITY_TYPE_descriptor(), name, value);
}
enum CAMP_TYPE {
  CAMP_TYPE_NIL = 1,
  CAMP_TYPE_HUMON = 2
};
bool CAMP_TYPE_IsValid(int value);
const CAMP_TYPE CAMP_TYPE_MIN = CAMP_TYPE_NIL;
const CAMP_TYPE CAMP_TYPE_MAX = CAMP_TYPE_HUMON;
const int CAMP_TYPE_ARRAYSIZE = CAMP_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CAMP_TYPE_descriptor();
inline const ::std::string& CAMP_TYPE_Name(CAMP_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CAMP_TYPE_descriptor(), value);
}
inline bool CAMP_TYPE_Parse(
    const ::std::string& name, CAMP_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CAMP_TYPE>(
    CAMP_TYPE_descriptor(), name, value);
}
enum VERSION_TYPE {
  VERSION_TYPE_GLOBAL = 1,
  VERSION_TYPE_MAINLAND = 2,
  VERSION_TYPE_TAIWAN = 3
};
bool VERSION_TYPE_IsValid(int value);
const VERSION_TYPE VERSION_TYPE_MIN = VERSION_TYPE_GLOBAL;
const VERSION_TYPE VERSION_TYPE_MAX = VERSION_TYPE_TAIWAN;
const int VERSION_TYPE_ARRAYSIZE = VERSION_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* VERSION_TYPE_descriptor();
inline const ::std::string& VERSION_TYPE_Name(VERSION_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    VERSION_TYPE_descriptor(), value);
}
inline bool VERSION_TYPE_Parse(
    const ::std::string& name, VERSION_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VERSION_TYPE>(
    VERSION_TYPE_descriptor(), name, value);
}
enum ASSET_TYPE {
  ASSET_TYPE_BEGIN = 1,
  ASSET_TYPE_PLANT = 2,
  ASSET_TYPE_COMMON_LIMIT = 3,
  ASSET_TYPE_COMMON_REWARD = 4,
  ASSET_TYPE_COOL_DOWN = 5,
  ASSET_TYPE_HOSTER = 6,
  ASSET_TYPE_SKILL = 7,
  ASSET_TYPE_LEVEL_UP = 8,
  ASSET_TYPE_SCENE = 9,
  ASSET_TYPE_PARTICLE = 10,
  ASSET_TYPE_COUNT = 200,
  ITEM_TYPE_BEGIN = 201,
  ITEM_TYPE_POTION = 202,
  ITEM_TYPE_EQUIPMENT = 203,
  ITEM_TYPE_GUN = 204
};
bool ASSET_TYPE_IsValid(int value);
const ASSET_TYPE ASSET_TYPE_MIN = ASSET_TYPE_BEGIN;
const ASSET_TYPE ASSET_TYPE_MAX = ITEM_TYPE_GUN;
const int ASSET_TYPE_ARRAYSIZE = ASSET_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ASSET_TYPE_descriptor();
inline const ::std::string& ASSET_TYPE_Name(ASSET_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ASSET_TYPE_descriptor(), value);
}
inline bool ASSET_TYPE_Parse(
    const ::std::string& name, ASSET_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ASSET_TYPE>(
    ASSET_TYPE_descriptor(), name, value);
}
// ===================================================================

class Vector2 : public ::google::protobuf::Message {
 public:
  Vector2();
  virtual ~Vector2();

  Vector2(const Vector2& from);

  inline Vector2& operator=(const Vector2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector2& default_instance();

  void Swap(Vector2* other);

  // implements Message ----------------------------------------------

  Vector2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector2& from);
  void MergeFrom(const Vector2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float z = 2;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 2;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Vector2)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float z_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Vector2* default_instance_;
};
// -------------------------------------------------------------------

class Vector3 : public ::google::protobuf::Message {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  void Swap(Vector3* other);

  // implements Message ----------------------------------------------

  Vector3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Vector3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Vector3* default_instance_;
};
// -------------------------------------------------------------------

class CommonProp : public ::google::protobuf::Message {
 public:
  CommonProp();
  virtual ~CommonProp();

  CommonProp(const CommonProp& from);

  inline CommonProp& operator=(const CommonProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonProp& default_instance();

  void Swap(CommonProp* other);

  // implements Message ----------------------------------------------

  CommonProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonProp& from);
  void MergeFrom(const CommonProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional .Adoter.Asset.ENTITY_TYPE entity_type = 2;
  inline bool has_entity_type() const;
  inline void clear_entity_type();
  static const int kEntityTypeFieldNumber = 2;
  inline ::Adoter::Asset::ENTITY_TYPE entity_type() const;
  inline void set_entity_type(::Adoter::Asset::ENTITY_TYPE value);

  // optional bytes name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 radius = 4;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 4;
  inline ::google::protobuf::int32 radius() const;
  inline void set_radius(::google::protobuf::int32 value);

  // optional int32 height = 5;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 5;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 level = 6;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 6;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 gender = 7;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 7;
  inline ::google::protobuf::int32 gender() const;
  inline void set_gender(::google::protobuf::int32 value);

  // optional int32 profession = 8;
  inline bool has_profession() const;
  inline void clear_profession();
  static const int kProfessionFieldNumber = 8;
  inline ::google::protobuf::int32 profession() const;
  inline void set_profession(::google::protobuf::int32 value);

  // optional int32 speed = 9;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 9;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // optional int32 hp = 10;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 10;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // optional int32 mp = 11;
  inline bool has_mp() const;
  inline void clear_mp();
  static const int kMpFieldNumber = 11;
  inline ::google::protobuf::int32 mp() const;
  inline void set_mp(::google::protobuf::int32 value);

  // optional int32 orientation_x = 12;
  inline bool has_orientation_x() const;
  inline void clear_orientation_x();
  static const int kOrientationXFieldNumber = 12;
  inline ::google::protobuf::int32 orientation_x() const;
  inline void set_orientation_x(::google::protobuf::int32 value);

  // optional int32 orientation_y = 13;
  inline bool has_orientation_y() const;
  inline void clear_orientation_y();
  static const int kOrientationYFieldNumber = 13;
  inline ::google::protobuf::int32 orientation_y() const;
  inline void set_orientation_y(::google::protobuf::int32 value);

  // optional int32 scene_id = 14;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 14;
  inline ::google::protobuf::int32 scene_id() const;
  inline void set_scene_id(::google::protobuf::int32 value);

  // optional .Adoter.Asset.Vector3 position = 15;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 15;
  inline const ::Adoter::Asset::Vector3& position() const;
  inline ::Adoter::Asset::Vector3* mutable_position();
  inline ::Adoter::Asset::Vector3* release_position();
  inline void set_allocated_position(::Adoter::Asset::Vector3* position);

  // optional float visibility_range = 16 [default = 90];
  inline bool has_visibility_range() const;
  inline void clear_visibility_range();
  static const int kVisibilityRangeFieldNumber = 16;
  inline float visibility_range() const;
  inline void set_visibility_range(float value);

  // optional .Adoter.Asset.CAMP_TYPE camp_type = 17;
  inline bool has_camp_type() const;
  inline void clear_camp_type();
  static const int kCampTypeFieldNumber = 17;
  inline ::Adoter::Asset::CAMP_TYPE camp_type() const;
  inline void set_camp_type(::Adoter::Asset::CAMP_TYPE value);

  // optional int32 skills_count = 18 [default = 4];
  inline bool has_skills_count() const;
  inline void clear_skills_count();
  static const int kSkillsCountFieldNumber = 18;
  inline ::google::protobuf::int32 skills_count() const;
  inline void set_skills_count(::google::protobuf::int32 value);

  // repeated int32 skills = 19;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 19;
  inline ::google::protobuf::int32 skills(int index) const;
  inline void set_skills(int index, ::google::protobuf::int32 value);
  inline void add_skills(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      skills() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_skills();

  // optional int32 level_up_id = 20;
  inline bool has_level_up_id() const;
  inline void clear_level_up_id();
  static const int kLevelUpIdFieldNumber = 20;
  inline ::google::protobuf::int32 level_up_id() const;
  inline void set_level_up_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CommonProp)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_entity_type();
  inline void clear_has_entity_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_profession();
  inline void clear_has_profession();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_mp();
  inline void clear_has_mp();
  inline void set_has_orientation_x();
  inline void clear_has_orientation_x();
  inline void set_has_orientation_y();
  inline void clear_has_orientation_y();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_visibility_range();
  inline void clear_has_visibility_range();
  inline void set_has_camp_type();
  inline void clear_has_camp_type();
  inline void set_has_skills_count();
  inline void clear_has_skills_count();
  inline void set_has_level_up_id();
  inline void clear_has_level_up_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 id_;
  ::std::string* name_;
  int entity_type_;
  ::google::protobuf::int32 radius_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 gender_;
  ::google::protobuf::int32 profession_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 mp_;
  ::google::protobuf::int32 orientation_x_;
  ::google::protobuf::int32 orientation_y_;
  ::google::protobuf::int32 scene_id_;
  ::Adoter::Asset::Vector3* position_;
  float visibility_range_;
  int camp_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > skills_;
  ::google::protobuf::int32 skills_count_;
  ::google::protobuf::int32 level_up_id_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static CommonProp* default_instance_;
};
// -------------------------------------------------------------------

class AssetCommonProp : public ::google::protobuf::Message {
 public:
  AssetCommonProp();
  virtual ~AssetCommonProp();

  AssetCommonProp(const AssetCommonProp& from);

  inline AssetCommonProp& operator=(const AssetCommonProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetCommonProp& default_instance();

  void Swap(AssetCommonProp* other);

  // implements Message ----------------------------------------------

  AssetCommonProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssetCommonProp& from);
  void MergeFrom(const AssetCommonProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 global_id = 1;
  inline bool has_global_id() const;
  inline void clear_global_id();
  static const int kGlobalIdFieldNumber = 1;
  inline ::google::protobuf::int64 global_id() const;
  inline void set_global_id(::google::protobuf::int64 value);

  // required int32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required .Adoter.Asset.VERSION_TYPE version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline ::Adoter::Asset::VERSION_TYPE version() const;
  inline void set_version(::Adoter::Asset::VERSION_TYPE value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string show_name = 5;
  inline bool has_show_name() const;
  inline void clear_show_name();
  static const int kShowNameFieldNumber = 5;
  inline const ::std::string& show_name() const;
  inline void set_show_name(const ::std::string& value);
  inline void set_show_name(const char* value);
  inline void set_show_name(const char* value, size_t size);
  inline ::std::string* mutable_show_name();
  inline ::std::string* release_show_name();
  inline void set_allocated_show_name(::std::string* show_name);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.AssetCommonProp)
 private:
  inline void set_has_global_id();
  inline void clear_has_global_id();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_show_name();
  inline void clear_has_show_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 global_id_;
  ::google::protobuf::int32 index_;
  int version_;
  ::std::string* name_;
  ::std::string* show_name_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static AssetCommonProp* default_instance_;
};
// -------------------------------------------------------------------

class Plant : public ::google::protobuf::Message {
 public:
  Plant();
  virtual ~Plant();

  Plant(const Plant& from);

  inline Plant& operator=(const Plant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Plant& default_instance();

  void Swap(Plant* other);

  // implements Message ----------------------------------------------

  Plant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Plant& from);
  void MergeFrom(const Plant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_PLANT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Plant)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Plant* default_instance_;
};
// -------------------------------------------------------------------

class CommonLimit : public ::google::protobuf::Message {
 public:
  CommonLimit();
  virtual ~CommonLimit();

  CommonLimit(const CommonLimit& from);

  inline CommonLimit& operator=(const CommonLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonLimit& default_instance();

  void Swap(CommonLimit* other);

  // implements Message ----------------------------------------------

  CommonLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonLimit& from);
  void MergeFrom(const CommonLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommonLimit_COMMON_LIMIT_TYPE COMMON_LIMIT_TYPE;
  static const COMMON_LIMIT_TYPE COMMON_LIMIT_TYPE_PLANT = CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_PLANT;
  static inline bool COMMON_LIMIT_TYPE_IsValid(int value) {
    return CommonLimit_COMMON_LIMIT_TYPE_IsValid(value);
  }
  static const COMMON_LIMIT_TYPE COMMON_LIMIT_TYPE_MIN =
    CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_MIN;
  static const COMMON_LIMIT_TYPE COMMON_LIMIT_TYPE_MAX =
    CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_MAX;
  static const int COMMON_LIMIT_TYPE_ARRAYSIZE =
    CommonLimit_COMMON_LIMIT_TYPE_COMMON_LIMIT_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  COMMON_LIMIT_TYPE_descriptor() {
    return CommonLimit_COMMON_LIMIT_TYPE_descriptor();
  }
  static inline const ::std::string& COMMON_LIMIT_TYPE_Name(COMMON_LIMIT_TYPE value) {
    return CommonLimit_COMMON_LIMIT_TYPE_Name(value);
  }
  static inline bool COMMON_LIMIT_TYPE_Parse(const ::std::string& name,
      COMMON_LIMIT_TYPE* value) {
    return CommonLimit_COMMON_LIMIT_TYPE_Parse(name, value);
  }

  typedef CommonLimit_COOL_DOWN_TYPE COOL_DOWN_TYPE;
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_DAY = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_DAY;
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_WEEK = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_WEEK;
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_MONTH = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MONTH;
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_YEAR = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_YEAR;
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_NEVER = CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_NEVER;
  static inline bool COOL_DOWN_TYPE_IsValid(int value) {
    return CommonLimit_COOL_DOWN_TYPE_IsValid(value);
  }
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_MIN =
    CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MIN;
  static const COOL_DOWN_TYPE COOL_DOWN_TYPE_MAX =
    CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_MAX;
  static const int COOL_DOWN_TYPE_ARRAYSIZE =
    CommonLimit_COOL_DOWN_TYPE_COOL_DOWN_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  COOL_DOWN_TYPE_descriptor() {
    return CommonLimit_COOL_DOWN_TYPE_descriptor();
  }
  static inline const ::std::string& COOL_DOWN_TYPE_Name(COOL_DOWN_TYPE value) {
    return CommonLimit_COOL_DOWN_TYPE_Name(value);
  }
  static inline bool COOL_DOWN_TYPE_Parse(const ::std::string& name,
      COOL_DOWN_TYPE* value) {
    return CommonLimit_COOL_DOWN_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COMMON_LIMIT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional .Adoter.Asset.CommonLimit.COMMON_LIMIT_TYPE limit_type = 3;
  inline bool has_limit_type() const;
  inline void clear_limit_type();
  static const int kLimitTypeFieldNumber = 3;
  inline ::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE limit_type() const;
  inline void set_limit_type(::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE value);

  // optional .Adoter.Asset.CommonLimit.COOL_DOWN_TYPE cool_down_type = 4;
  inline bool has_cool_down_type() const;
  inline void clear_cool_down_type();
  static const int kCoolDownTypeFieldNumber = 4;
  inline ::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE cool_down_type() const;
  inline void set_cool_down_type(::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CommonLimit)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_limit_type();
  inline void clear_has_limit_type();
  inline void set_has_cool_down_type();
  inline void clear_has_cool_down_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  int limit_type_;
  int cool_down_type_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static CommonLimit* default_instance_;
};
// -------------------------------------------------------------------

class CoolDown : public ::google::protobuf::Message {
 public:
  CoolDown();
  virtual ~CoolDown();

  CoolDown(const CoolDown& from);

  inline CoolDown& operator=(const CoolDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoolDown& default_instance();

  void Swap(CoolDown* other);

  // implements Message ----------------------------------------------

  CoolDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoolDown& from);
  void MergeFrom(const CoolDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COOL_DOWN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.CoolDown)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 time_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static CoolDown* default_instance_;
};
// -------------------------------------------------------------------

class Hoster : public ::google::protobuf::Message {
 public:
  Hoster();
  virtual ~Hoster();

  Hoster(const Hoster& from);

  inline Hoster& operator=(const Hoster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hoster& default_instance();

  void Swap(Hoster* other);

  // implements Message ----------------------------------------------

  Hoster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hoster& from);
  void MergeFrom(const Hoster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_HOSTER];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional .Adoter.Asset.CommonProp human_prop = 3;
  inline bool has_human_prop() const;
  inline void clear_human_prop();
  static const int kHumanPropFieldNumber = 3;
  inline const ::Adoter::Asset::CommonProp& human_prop() const;
  inline ::Adoter::Asset::CommonProp* mutable_human_prop();
  inline ::Adoter::Asset::CommonProp* release_human_prop();
  inline void set_allocated_human_prop(::Adoter::Asset::CommonProp* human_prop);

  // optional string behaviac_tree_path = 4;
  inline bool has_behaviac_tree_path() const;
  inline void clear_behaviac_tree_path();
  static const int kBehaviacTreePathFieldNumber = 4;
  inline const ::std::string& behaviac_tree_path() const;
  inline void set_behaviac_tree_path(const ::std::string& value);
  inline void set_behaviac_tree_path(const char* value);
  inline void set_behaviac_tree_path(const char* value, size_t size);
  inline ::std::string* mutable_behaviac_tree_path();
  inline ::std::string* release_behaviac_tree_path();
  inline void set_allocated_behaviac_tree_path(::std::string* behaviac_tree_path);

  // optional int32 build_time = 5;
  inline bool has_build_time() const;
  inline void clear_build_time();
  static const int kBuildTimeFieldNumber = 5;
  inline ::google::protobuf::int32 build_time() const;
  inline void set_build_time(::google::protobuf::int32 value);

  // optional int32 attack_speed = 6;
  inline bool has_attack_speed() const;
  inline void clear_attack_speed();
  static const int kAttackSpeedFieldNumber = 6;
  inline ::google::protobuf::int32 attack_speed() const;
  inline void set_attack_speed(::google::protobuf::int32 value);

  // optional int32 produce_entity_id = 7;
  inline bool has_produce_entity_id() const;
  inline void clear_produce_entity_id();
  static const int kProduceEntityIdFieldNumber = 7;
  inline ::google::protobuf::int32 produce_entity_id() const;
  inline void set_produce_entity_id(::google::protobuf::int32 value);

  // optional int32 produce_entity_speed = 8;
  inline bool has_produce_entity_speed() const;
  inline void clear_produce_entity_speed();
  static const int kProduceEntitySpeedFieldNumber = 8;
  inline ::google::protobuf::int32 produce_entity_speed() const;
  inline void set_produce_entity_speed(::google::protobuf::int32 value);

  // optional int32 produce_entity_count = 9;
  inline bool has_produce_entity_count() const;
  inline void clear_produce_entity_count();
  static const int kProduceEntityCountFieldNumber = 9;
  inline ::google::protobuf::int32 produce_entity_count() const;
  inline void set_produce_entity_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Hoster)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_human_prop();
  inline void clear_has_human_prop();
  inline void set_has_behaviac_tree_path();
  inline void clear_has_behaviac_tree_path();
  inline void set_has_build_time();
  inline void clear_has_build_time();
  inline void set_has_attack_speed();
  inline void clear_has_attack_speed();
  inline void set_has_produce_entity_id();
  inline void clear_has_produce_entity_id();
  inline void set_has_produce_entity_speed();
  inline void clear_has_produce_entity_speed();
  inline void set_has_produce_entity_count();
  inline void clear_has_produce_entity_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  ::Adoter::Asset::CommonProp* human_prop_;
  int type_t_;
  ::google::protobuf::int32 build_time_;
  ::std::string* behaviac_tree_path_;
  ::google::protobuf::int32 attack_speed_;
  ::google::protobuf::int32 produce_entity_id_;
  ::google::protobuf::int32 produce_entity_speed_;
  ::google::protobuf::int32 produce_entity_count_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Hoster* default_instance_;
};
// -------------------------------------------------------------------

class Harm : public ::google::protobuf::Message {
 public:
  Harm();
  virtual ~Harm();

  Harm(const Harm& from);

  inline Harm& operator=(const Harm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Harm& default_instance();

  void Swap(Harm* other);

  // implements Message ----------------------------------------------

  Harm* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Harm& from);
  void MergeFrom(const Harm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Harm_HARM_TYPE HARM_TYPE;
  static const HARM_TYPE HARM_TYPE_HP = Harm_HARM_TYPE_HARM_TYPE_HP;
  static const HARM_TYPE HARM_TYPE_MP = Harm_HARM_TYPE_HARM_TYPE_MP;
  static const HARM_TYPE HARM_TYPE_SPEED = Harm_HARM_TYPE_HARM_TYPE_SPEED;
  static inline bool HARM_TYPE_IsValid(int value) {
    return Harm_HARM_TYPE_IsValid(value);
  }
  static const HARM_TYPE HARM_TYPE_MIN =
    Harm_HARM_TYPE_HARM_TYPE_MIN;
  static const HARM_TYPE HARM_TYPE_MAX =
    Harm_HARM_TYPE_HARM_TYPE_MAX;
  static const int HARM_TYPE_ARRAYSIZE =
    Harm_HARM_TYPE_HARM_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HARM_TYPE_descriptor() {
    return Harm_HARM_TYPE_descriptor();
  }
  static inline const ::std::string& HARM_TYPE_Name(HARM_TYPE value) {
    return Harm_HARM_TYPE_Name(value);
  }
  static inline bool HARM_TYPE_Parse(const ::std::string& name,
      HARM_TYPE* value) {
    return Harm_HARM_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.Harm.HARM_TYPE harm_type = 1;
  inline bool has_harm_type() const;
  inline void clear_harm_type();
  static const int kHarmTypeFieldNumber = 1;
  inline ::Adoter::Asset::Harm_HARM_TYPE harm_type() const;
  inline void set_harm_type(::Adoter::Asset::Harm_HARM_TYPE value);

  // optional int32 harm_total = 2;
  inline bool has_harm_total() const;
  inline void clear_harm_total();
  static const int kHarmTotalFieldNumber = 2;
  inline ::google::protobuf::int32 harm_total() const;
  inline void set_harm_total(::google::protobuf::int32 value);

  // optional int32 last_time = 3;
  inline bool has_last_time() const;
  inline void clear_last_time();
  static const int kLastTimeFieldNumber = 3;
  inline ::google::protobuf::int32 last_time() const;
  inline void set_last_time(::google::protobuf::int32 value);

  // optional int32 harm_per_second = 4;
  inline bool has_harm_per_second() const;
  inline void clear_harm_per_second();
  static const int kHarmPerSecondFieldNumber = 4;
  inline ::google::protobuf::int32 harm_per_second() const;
  inline void set_harm_per_second(::google::protobuf::int32 value);

  // optional int32 harm_range = 5;
  inline bool has_harm_range() const;
  inline void clear_harm_range();
  static const int kHarmRangeFieldNumber = 5;
  inline ::google::protobuf::int32 harm_range() const;
  inline void set_harm_range(::google::protobuf::int32 value);

  // optional .Adoter.Asset.ENTITY_TYPE harm_target = 6;
  inline bool has_harm_target() const;
  inline void clear_harm_target();
  static const int kHarmTargetFieldNumber = 6;
  inline ::Adoter::Asset::ENTITY_TYPE harm_target() const;
  inline void set_harm_target(::Adoter::Asset::ENTITY_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Harm)
 private:
  inline void set_has_harm_type();
  inline void clear_has_harm_type();
  inline void set_has_harm_total();
  inline void clear_has_harm_total();
  inline void set_has_last_time();
  inline void clear_has_last_time();
  inline void set_has_harm_per_second();
  inline void clear_has_harm_per_second();
  inline void set_has_harm_range();
  inline void clear_has_harm_range();
  inline void set_has_harm_target();
  inline void clear_has_harm_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int harm_type_;
  ::google::protobuf::int32 harm_total_;
  ::google::protobuf::int32 last_time_;
  ::google::protobuf::int32 harm_per_second_;
  ::google::protobuf::int32 harm_range_;
  int harm_target_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Harm* default_instance_;
};
// -------------------------------------------------------------------

class Skill : public ::google::protobuf::Message {
 public:
  Skill();
  virtual ~Skill();

  Skill(const Skill& from);

  inline Skill& operator=(const Skill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Skill& default_instance();

  void Swap(Skill* other);

  // implements Message ----------------------------------------------

  Skill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Skill& from);
  void MergeFrom(const Skill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_SKILL];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional string behaviac_tree_path = 4;
  inline bool has_behaviac_tree_path() const;
  inline void clear_behaviac_tree_path();
  static const int kBehaviacTreePathFieldNumber = 4;
  inline const ::std::string& behaviac_tree_path() const;
  inline void set_behaviac_tree_path(const ::std::string& value);
  inline void set_behaviac_tree_path(const char* value);
  inline void set_behaviac_tree_path(const char* value, size_t size);
  inline ::std::string* mutable_behaviac_tree_path();
  inline ::std::string* release_behaviac_tree_path();
  inline void set_allocated_behaviac_tree_path(::std::string* behaviac_tree_path);

  // optional int32 cool_down_id = 5;
  inline bool has_cool_down_id() const;
  inline void clear_cool_down_id();
  static const int kCoolDownIdFieldNumber = 5;
  inline ::google::protobuf::int32 cool_down_id() const;
  inline void set_cool_down_id(::google::protobuf::int32 value);

  // optional int32 defense = 6;
  inline bool has_defense() const;
  inline void clear_defense();
  static const int kDefenseFieldNumber = 6;
  inline ::google::protobuf::int32 defense() const;
  inline void set_defense(::google::protobuf::int32 value);

  // optional .Adoter.Asset.Harm harm = 7;
  inline bool has_harm() const;
  inline void clear_harm();
  static const int kHarmFieldNumber = 7;
  inline const ::Adoter::Asset::Harm& harm() const;
  inline ::Adoter::Asset::Harm* mutable_harm();
  inline ::Adoter::Asset::Harm* release_harm();
  inline void set_allocated_harm(::Adoter::Asset::Harm* harm);

  // optional int32 summon_entity_id = 8;
  inline bool has_summon_entity_id() const;
  inline void clear_summon_entity_id();
  static const int kSummonEntityIdFieldNumber = 8;
  inline ::google::protobuf::int32 summon_entity_id() const;
  inline void set_summon_entity_id(::google::protobuf::int32 value);

  // optional int32 death_harm_total = 9;
  inline bool has_death_harm_total() const;
  inline void clear_death_harm_total();
  static const int kDeathHarmTotalFieldNumber = 9;
  inline ::google::protobuf::int32 death_harm_total() const;
  inline void set_death_harm_total(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Skill)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_behaviac_tree_path();
  inline void clear_has_behaviac_tree_path();
  inline void set_has_cool_down_id();
  inline void clear_has_cool_down_id();
  inline void set_has_defense();
  inline void clear_has_defense();
  inline void set_has_harm();
  inline void clear_has_harm();
  inline void set_has_summon_entity_id();
  inline void clear_has_summon_entity_id();
  inline void set_has_death_harm_total();
  inline void clear_has_death_harm_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 level_;
  ::std::string* behaviac_tree_path_;
  ::google::protobuf::int32 cool_down_id_;
  ::google::protobuf::int32 defense_;
  ::Adoter::Asset::Harm* harm_;
  ::google::protobuf::int32 summon_entity_id_;
  ::google::protobuf::int32 death_harm_total_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Skill* default_instance_;
};
// -------------------------------------------------------------------

class LevelUpCurve_Consume : public ::google::protobuf::Message {
 public:
  LevelUpCurve_Consume();
  virtual ~LevelUpCurve_Consume();

  LevelUpCurve_Consume(const LevelUpCurve_Consume& from);

  inline LevelUpCurve_Consume& operator=(const LevelUpCurve_Consume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LevelUpCurve_Consume& default_instance();

  void Swap(LevelUpCurve_Consume* other);

  // implements Message ----------------------------------------------

  LevelUpCurve_Consume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LevelUpCurve_Consume& from);
  void MergeFrom(const LevelUpCurve_Consume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LevelUpCurve_Consume_CONSUME_TYPE CONSUME_TYPE;
  static const CONSUME_TYPE CONSUME_TYPE_EXPERIENCE = LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_EXPERIENCE;
  static const CONSUME_TYPE CONSUME_TYPE_DIOMAND = LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_DIOMAND;
  static const CONSUME_TYPE CONSUME_TYPE_TIME = LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_TIME;
  static inline bool CONSUME_TYPE_IsValid(int value) {
    return LevelUpCurve_Consume_CONSUME_TYPE_IsValid(value);
  }
  static const CONSUME_TYPE CONSUME_TYPE_MIN =
    LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_MIN;
  static const CONSUME_TYPE CONSUME_TYPE_MAX =
    LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_MAX;
  static const int CONSUME_TYPE_ARRAYSIZE =
    LevelUpCurve_Consume_CONSUME_TYPE_CONSUME_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CONSUME_TYPE_descriptor() {
    return LevelUpCurve_Consume_CONSUME_TYPE_descriptor();
  }
  static inline const ::std::string& CONSUME_TYPE_Name(CONSUME_TYPE value) {
    return LevelUpCurve_Consume_CONSUME_TYPE_Name(value);
  }
  static inline bool CONSUME_TYPE_Parse(const ::std::string& name,
      CONSUME_TYPE* value) {
    return LevelUpCurve_Consume_CONSUME_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 level_up = 1;
  inline bool has_level_up() const;
  inline void clear_level_up();
  static const int kLevelUpFieldNumber = 1;
  inline ::google::protobuf::int32 level_up() const;
  inline void set_level_up(::google::protobuf::int32 value);

  // optional .Adoter.Asset.LevelUpCurve.Consume.CONSUME_TYPE consume_type = 2;
  inline bool has_consume_type() const;
  inline void clear_consume_type();
  static const int kConsumeTypeFieldNumber = 2;
  inline ::Adoter::Asset::LevelUpCurve_Consume_CONSUME_TYPE consume_type() const;
  inline void set_consume_type(::Adoter::Asset::LevelUpCurve_Consume_CONSUME_TYPE value);

  // optional int32 consume_value = 3;
  inline bool has_consume_value() const;
  inline void clear_consume_value();
  static const int kConsumeValueFieldNumber = 3;
  inline ::google::protobuf::int32 consume_value() const;
  inline void set_consume_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.LevelUpCurve.Consume)
 private:
  inline void set_has_level_up();
  inline void clear_has_level_up();
  inline void set_has_consume_type();
  inline void clear_has_consume_type();
  inline void set_has_consume_value();
  inline void clear_has_consume_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 level_up_;
  int consume_type_;
  ::google::protobuf::int32 consume_value_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static LevelUpCurve_Consume* default_instance_;
};
// -------------------------------------------------------------------

class LevelUpCurve : public ::google::protobuf::Message {
 public:
  LevelUpCurve();
  virtual ~LevelUpCurve();

  LevelUpCurve(const LevelUpCurve& from);

  inline LevelUpCurve& operator=(const LevelUpCurve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LevelUpCurve& default_instance();

  void Swap(LevelUpCurve* other);

  // implements Message ----------------------------------------------

  LevelUpCurve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LevelUpCurve& from);
  void MergeFrom(const LevelUpCurve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LevelUpCurve_Consume Consume;

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_LEVEL_UP];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 consumes_count = 3 [default = 20];
  inline bool has_consumes_count() const;
  inline void clear_consumes_count();
  static const int kConsumesCountFieldNumber = 3;
  inline ::google::protobuf::int32 consumes_count() const;
  inline void set_consumes_count(::google::protobuf::int32 value);

  // repeated .Adoter.Asset.LevelUpCurve.Consume consumes = 4;
  inline int consumes_size() const;
  inline void clear_consumes();
  static const int kConsumesFieldNumber = 4;
  inline const ::Adoter::Asset::LevelUpCurve_Consume& consumes(int index) const;
  inline ::Adoter::Asset::LevelUpCurve_Consume* mutable_consumes(int index);
  inline ::Adoter::Asset::LevelUpCurve_Consume* add_consumes();
  inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LevelUpCurve_Consume >&
      consumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LevelUpCurve_Consume >*
      mutable_consumes();

  // @@protoc_insertion_point(class_scope:Adoter.Asset.LevelUpCurve)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_consumes_count();
  inline void clear_has_consumes_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 consumes_count_;
  ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LevelUpCurve_Consume > consumes_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static LevelUpCurve* default_instance_;
};
// -------------------------------------------------------------------

class Scene : public ::google::protobuf::Message {
 public:
  Scene();
  virtual ~Scene();

  Scene(const Scene& from);

  inline Scene& operator=(const Scene& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scene& default_instance();

  void Swap(Scene* other);

  // implements Message ----------------------------------------------

  Scene* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scene& from);
  void MergeFrom(const Scene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_SCENE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 length = 3;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 3;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // optional int32 width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional string terrain_path = 5;
  inline bool has_terrain_path() const;
  inline void clear_terrain_path();
  static const int kTerrainPathFieldNumber = 5;
  inline const ::std::string& terrain_path() const;
  inline void set_terrain_path(const ::std::string& value);
  inline void set_terrain_path(const char* value);
  inline void set_terrain_path(const char* value, size_t size);
  inline ::std::string* mutable_terrain_path();
  inline ::std::string* release_terrain_path();
  inline void set_allocated_terrain_path(::std::string* terrain_path);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Scene)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_terrain_path();
  inline void clear_has_terrain_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 length_;
  ::std::string* terrain_path_;
  ::google::protobuf::int32 width_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Scene* default_instance_;
};
// -------------------------------------------------------------------

class Particle : public ::google::protobuf::Message {
 public:
  Particle();
  virtual ~Particle();

  Particle(const Particle& from);

  inline Particle& operator=(const Particle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Particle& default_instance();

  void Swap(Particle* other);

  // implements Message ----------------------------------------------

  Particle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Particle& from);
  void MergeFrom(const Particle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_PARTICLE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.AssetCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional .Adoter.Asset.ENTITY_TYPE entity_type = 3;
  inline bool has_entity_type() const;
  inline void clear_entity_type();
  static const int kEntityTypeFieldNumber = 3;
  inline ::Adoter::Asset::ENTITY_TYPE entity_type() const;
  inline void set_entity_type(::Adoter::Asset::ENTITY_TYPE value);

  // optional int32 speed = 4;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 4;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // optional int32 orientation_x = 5;
  inline bool has_orientation_x() const;
  inline void clear_orientation_x();
  static const int kOrientationXFieldNumber = 5;
  inline ::google::protobuf::int32 orientation_x() const;
  inline void set_orientation_x(::google::protobuf::int32 value);

  // optional int32 orientation_y = 6;
  inline bool has_orientation_y() const;
  inline void clear_orientation_y();
  static const int kOrientationYFieldNumber = 6;
  inline ::google::protobuf::int32 orientation_y() const;
  inline void set_orientation_y(::google::protobuf::int32 value);

  // optional .Adoter.Asset.Vector3 position = 7;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 7;
  inline const ::Adoter::Asset::Vector3& position() const;
  inline ::Adoter::Asset::Vector3* mutable_position();
  inline ::Adoter::Asset::Vector3* release_position();
  inline void set_allocated_position(::Adoter::Asset::Vector3* position);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Particle)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_entity_type();
  inline void clear_has_entity_type();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_orientation_x();
  inline void clear_has_orientation_x();
  inline void set_has_orientation_y();
  inline void clear_has_orientation_y();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  int type_t_;
  int entity_type_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 orientation_x_;
  ::Adoter::Asset::Vector3* position_;
  ::google::protobuf::int32 orientation_y_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Particle* default_instance_;
};
// -------------------------------------------------------------------

class Item_CommonProp : public ::google::protobuf::Message {
 public:
  Item_CommonProp();
  virtual ~Item_CommonProp();

  Item_CommonProp(const Item_CommonProp& from);

  inline Item_CommonProp& operator=(const Item_CommonProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_CommonProp& default_instance();

  void Swap(Item_CommonProp* other);

  // implements Message ----------------------------------------------

  Item_CommonProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_CommonProp& from);
  void MergeFrom(const Item_CommonProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.AssetCommonProp common_prop = 1;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 1;
  inline const ::Adoter::Asset::AssetCommonProp& common_prop() const;
  inline ::Adoter::Asset::AssetCommonProp* mutable_common_prop();
  inline ::Adoter::Asset::AssetCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop);

  // optional int32 quality = 2;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 2;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // optional int32 min_level_limit = 3;
  inline bool has_min_level_limit() const;
  inline void clear_min_level_limit();
  static const int kMinLevelLimitFieldNumber = 3;
  inline ::google::protobuf::int32 min_level_limit() const;
  inline void set_min_level_limit(::google::protobuf::int32 value);

  // optional int32 max_level_limit = 4;
  inline bool has_max_level_limit() const;
  inline void clear_max_level_limit();
  static const int kMaxLevelLimitFieldNumber = 4;
  inline ::google::protobuf::int32 max_level_limit() const;
  inline void set_max_level_limit(::google::protobuf::int32 value);

  // optional int32 pile_max = 5;
  inline bool has_pile_max() const;
  inline void clear_pile_max();
  static const int kPileMaxFieldNumber = 5;
  inline ::google::protobuf::int32 pile_max() const;
  inline void set_pile_max(::google::protobuf::int32 value);

  // optional int32 batch_use = 6;
  inline bool has_batch_use() const;
  inline void clear_batch_use();
  static const int kBatchUseFieldNumber = 6;
  inline ::google::protobuf::int32 batch_use() const;
  inline void set_batch_use(::google::protobuf::int32 value);

  // optional int32 auto_use = 7;
  inline bool has_auto_use() const;
  inline void clear_auto_use();
  static const int kAutoUseFieldNumber = 7;
  inline ::google::protobuf::int32 auto_use() const;
  inline void set_auto_use(::google::protobuf::int32 value);

  // optional int32 cool_down_id = 8;
  inline bool has_cool_down_id() const;
  inline void clear_cool_down_id();
  static const int kCoolDownIdFieldNumber = 8;
  inline ::google::protobuf::int32 cool_down_id() const;
  inline void set_cool_down_id(::google::protobuf::int32 value);

  // optional .Adoter.Asset.INVENTORY_TYPE inventory = 9;
  inline bool has_inventory() const;
  inline void clear_inventory();
  static const int kInventoryFieldNumber = 9;
  inline ::Adoter::Asset::INVENTORY_TYPE inventory() const;
  inline void set_inventory(::Adoter::Asset::INVENTORY_TYPE value);

  // optional .Adoter.Asset.PROF_TYPE prof_mask = 10;
  inline bool has_prof_mask() const;
  inline void clear_prof_mask();
  static const int kProfMaskFieldNumber = 10;
  inline ::Adoter::Asset::PROF_TYPE prof_mask() const;
  inline void set_prof_mask(::Adoter::Asset::PROF_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Item_CommonProp)
 private:
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_min_level_limit();
  inline void clear_has_min_level_limit();
  inline void set_has_max_level_limit();
  inline void clear_has_max_level_limit();
  inline void set_has_pile_max();
  inline void clear_has_pile_max();
  inline void set_has_batch_use();
  inline void clear_has_batch_use();
  inline void set_has_auto_use();
  inline void clear_has_auto_use();
  inline void set_has_cool_down_id();
  inline void clear_has_cool_down_id();
  inline void set_has_inventory();
  inline void clear_has_inventory();
  inline void set_has_prof_mask();
  inline void clear_has_prof_mask();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::AssetCommonProp* common_prop_;
  ::google::protobuf::int32 quality_;
  ::google::protobuf::int32 min_level_limit_;
  ::google::protobuf::int32 max_level_limit_;
  ::google::protobuf::int32 pile_max_;
  ::google::protobuf::int32 batch_use_;
  ::google::protobuf::int32 auto_use_;
  ::google::protobuf::int32 cool_down_id_;
  int inventory_;
  int prof_mask_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Item_CommonProp* default_instance_;
};
// -------------------------------------------------------------------

class Item_Item : public ::google::protobuf::Message {
 public:
  Item_Item();
  virtual ~Item_Item();

  Item_Item(const Item_Item& from);

  inline Item_Item& operator=(const Item_Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_Item& default_instance();

  void Swap(Item_Item* other);

  // implements Message ----------------------------------------------

  Item_Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_Item& from);
  void MergeFrom(const Item_Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_BEGIN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional bytes stuff = 2;
  inline bool has_stuff() const;
  inline void clear_stuff();
  static const int kStuffFieldNumber = 2;
  inline const ::std::string& stuff() const;
  inline void set_stuff(const ::std::string& value);
  inline void set_stuff(const char* value);
  inline void set_stuff(const void* value, size_t size);
  inline ::std::string* mutable_stuff();
  inline ::std::string* release_stuff();
  inline void set_allocated_stuff(::std::string* stuff);

  // optional bytes stuff_extra = 3;
  inline bool has_stuff_extra() const;
  inline void clear_stuff_extra();
  static const int kStuffExtraFieldNumber = 3;
  inline const ::std::string& stuff_extra() const;
  inline void set_stuff_extra(const ::std::string& value);
  inline void set_stuff_extra(const char* value);
  inline void set_stuff_extra(const void* value, size_t size);
  inline ::std::string* mutable_stuff_extra();
  inline ::std::string* release_stuff_extra();
  inline void set_allocated_stuff_extra(::std::string* stuff_extra);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Item_Item)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_stuff();
  inline void clear_has_stuff();
  inline void set_has_stuff_extra();
  inline void clear_has_stuff_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* stuff_;
  ::std::string* stuff_extra_;
  int type_t_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Item_Item* default_instance_;
};
// -------------------------------------------------------------------

class Item_Potion : public ::google::protobuf::Message {
 public:
  Item_Potion();
  virtual ~Item_Potion();

  Item_Potion(const Item_Potion& from);

  inline Item_Potion& operator=(const Item_Potion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_Potion& default_instance();

  void Swap(Item_Potion* other);

  // implements Message ----------------------------------------------

  Item_Potion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_Potion& from);
  void MergeFrom(const Item_Potion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Item_Potion_POTION_TYPE POTION_TYPE;
  static const POTION_TYPE POTION_TYPE_HEMO = Item_Potion_POTION_TYPE_POTION_TYPE_HEMO;
  static const POTION_TYPE POTION_TYPE_MAGIC = Item_Potion_POTION_TYPE_POTION_TYPE_MAGIC;
  static const POTION_TYPE POTION_TYPE_PHYSICAL_STRENGTH = Item_Potion_POTION_TYPE_POTION_TYPE_PHYSICAL_STRENGTH;
  static inline bool POTION_TYPE_IsValid(int value) {
    return Item_Potion_POTION_TYPE_IsValid(value);
  }
  static const POTION_TYPE POTION_TYPE_MIN =
    Item_Potion_POTION_TYPE_POTION_TYPE_MIN;
  static const POTION_TYPE POTION_TYPE_MAX =
    Item_Potion_POTION_TYPE_POTION_TYPE_MAX;
  static const int POTION_TYPE_ARRAYSIZE =
    Item_Potion_POTION_TYPE_POTION_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  POTION_TYPE_descriptor() {
    return Item_Potion_POTION_TYPE_descriptor();
  }
  static inline const ::std::string& POTION_TYPE_Name(POTION_TYPE value) {
    return Item_Potion_POTION_TYPE_Name(value);
  }
  static inline bool POTION_TYPE_Parse(const ::std::string& name,
      POTION_TYPE* value) {
    return Item_Potion_POTION_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_POTION];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.Item_CommonProp item_common_prop = 2;
  inline bool has_item_common_prop() const;
  inline void clear_item_common_prop();
  static const int kItemCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::Item_CommonProp& item_common_prop() const;
  inline ::Adoter::Asset::Item_CommonProp* mutable_item_common_prop();
  inline ::Adoter::Asset::Item_CommonProp* release_item_common_prop();
  inline void set_allocated_item_common_prop(::Adoter::Asset::Item_CommonProp* item_common_prop);

  // optional .Adoter.Asset.Item_Potion.POTION_TYPE potion_type = 3;
  inline bool has_potion_type() const;
  inline void clear_potion_type();
  static const int kPotionTypeFieldNumber = 3;
  inline ::Adoter::Asset::Item_Potion_POTION_TYPE potion_type() const;
  inline void set_potion_type(::Adoter::Asset::Item_Potion_POTION_TYPE value);

  // optional int32 increase_value = 4;
  inline bool has_increase_value() const;
  inline void clear_increase_value();
  static const int kIncreaseValueFieldNumber = 4;
  inline ::google::protobuf::int32 increase_value() const;
  inline void set_increase_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Item_Potion)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_item_common_prop();
  inline void clear_has_item_common_prop();
  inline void set_has_potion_type();
  inline void clear_has_potion_type();
  inline void set_has_increase_value();
  inline void clear_has_increase_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Item_CommonProp* item_common_prop_;
  int type_t_;
  int potion_type_;
  ::google::protobuf::int32 increase_value_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Item_Potion* default_instance_;
};
// -------------------------------------------------------------------

class Item_Equipment : public ::google::protobuf::Message {
 public:
  Item_Equipment();
  virtual ~Item_Equipment();

  Item_Equipment(const Item_Equipment& from);

  inline Item_Equipment& operator=(const Item_Equipment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_Equipment& default_instance();

  void Swap(Item_Equipment* other);

  // implements Message ----------------------------------------------

  Item_Equipment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_Equipment& from);
  void MergeFrom(const Item_Equipment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Item_Equipment_EQUIP_TYPE EQUIP_TYPE;
  static const EQUIP_TYPE EQUIP_TYPE_HELMET = Item_Equipment_EQUIP_TYPE_EQUIP_TYPE_HELMET;
  static inline bool EQUIP_TYPE_IsValid(int value) {
    return Item_Equipment_EQUIP_TYPE_IsValid(value);
  }
  static const EQUIP_TYPE EQUIP_TYPE_MIN =
    Item_Equipment_EQUIP_TYPE_EQUIP_TYPE_MIN;
  static const EQUIP_TYPE EQUIP_TYPE_MAX =
    Item_Equipment_EQUIP_TYPE_EQUIP_TYPE_MAX;
  static const int EQUIP_TYPE_ARRAYSIZE =
    Item_Equipment_EQUIP_TYPE_EQUIP_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EQUIP_TYPE_descriptor() {
    return Item_Equipment_EQUIP_TYPE_descriptor();
  }
  static inline const ::std::string& EQUIP_TYPE_Name(EQUIP_TYPE value) {
    return Item_Equipment_EQUIP_TYPE_Name(value);
  }
  static inline bool EQUIP_TYPE_Parse(const ::std::string& name,
      EQUIP_TYPE* value) {
    return Item_Equipment_EQUIP_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_EQUIPMENT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::Adoter::Asset::ASSET_TYPE type_t() const;
  inline void set_type_t(::Adoter::Asset::ASSET_TYPE value);

  // optional .Adoter.Asset.Item_CommonProp item_common_prop = 2;
  inline bool has_item_common_prop() const;
  inline void clear_item_common_prop();
  static const int kItemCommonPropFieldNumber = 2;
  inline const ::Adoter::Asset::Item_CommonProp& item_common_prop() const;
  inline ::Adoter::Asset::Item_CommonProp* mutable_item_common_prop();
  inline ::Adoter::Asset::Item_CommonProp* release_item_common_prop();
  inline void set_allocated_item_common_prop(::Adoter::Asset::Item_CommonProp* item_common_prop);

  // optional .Adoter.Asset.Item_Equipment.EQUIP_TYPE equip_type = 3;
  inline bool has_equip_type() const;
  inline void clear_equip_type();
  static const int kEquipTypeFieldNumber = 3;
  inline ::Adoter::Asset::Item_Equipment_EQUIP_TYPE equip_type() const;
  inline void set_equip_type(::Adoter::Asset::Item_Equipment_EQUIP_TYPE value);

  // @@protoc_insertion_point(class_scope:Adoter.Asset.Item_Equipment)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_item_common_prop();
  inline void clear_has_item_common_prop();
  inline void set_has_equip_type();
  inline void clear_has_equip_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Adoter::Asset::Item_CommonProp* item_common_prop_;
  int type_t_;
  int equip_type_;
  friend void  protobuf_AddDesc_P_5fAsset_2eproto();
  friend void protobuf_AssignDesc_P_5fAsset_2eproto();
  friend void protobuf_ShutdownFile_P_5fAsset_2eproto();

  void InitAsDefaultInstance();
  static Item_Equipment* default_instance_;
};
// ===================================================================

static const int kInventorySizeFieldNumber = 60000;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int32 >, 5, false >
  inventory_size;
static const int kRepeatedSizeFieldNumber = 60001;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int32 >, 5, false >
  repeated_size;

// ===================================================================

// Vector2

// optional float x = 1;
inline bool Vector2::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector2::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector2::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector2::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector2::x() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Vector2.x)
  return x_;
}
inline void Vector2::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Vector2.x)
}

// optional float z = 2;
inline bool Vector2::has_z() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector2::set_has_z() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector2::clear_has_z() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector2::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector2::z() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Vector2.z)
  return z_;
}
inline void Vector2::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Vector2.z)
}

// -------------------------------------------------------------------

// Vector3

// optional float x = 1;
inline bool Vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Vector3.x)
  return x_;
}
inline void Vector3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Vector3.x)
}

// optional float y = 2;
inline bool Vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Vector3.y)
  return y_;
}
inline void Vector3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Vector3.y)
}

// optional float z = 3;
inline bool Vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Vector3.z)
  return z_;
}
inline void Vector3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Vector3.z)
}

// -------------------------------------------------------------------

// CommonProp

// optional int64 id = 1;
inline bool CommonProp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonProp::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonProp::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonProp::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 CommonProp::id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.id)
  return id_;
}
inline void CommonProp::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.id)
}

// optional .Adoter.Asset.ENTITY_TYPE entity_type = 2;
inline bool CommonProp::has_entity_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonProp::set_has_entity_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonProp::clear_has_entity_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonProp::clear_entity_type() {
  entity_type_ = 1;
  clear_has_entity_type();
}
inline ::Adoter::Asset::ENTITY_TYPE CommonProp::entity_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.entity_type)
  return static_cast< ::Adoter::Asset::ENTITY_TYPE >(entity_type_);
}
inline void CommonProp::set_entity_type(::Adoter::Asset::ENTITY_TYPE value) {
  assert(::Adoter::Asset::ENTITY_TYPE_IsValid(value));
  set_has_entity_type();
  entity_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.entity_type)
}

// optional bytes name = 3;
inline bool CommonProp::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonProp::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonProp::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonProp::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CommonProp::name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.name)
  return *name_;
}
inline void CommonProp::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.name)
}
inline void CommonProp::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.CommonProp.name)
}
inline void CommonProp::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.CommonProp.name)
}
inline ::std::string* CommonProp::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonProp.name)
  return name_;
}
inline ::std::string* CommonProp::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommonProp::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CommonProp.name)
}

// optional int32 radius = 4;
inline bool CommonProp::has_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonProp::set_has_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonProp::clear_has_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonProp::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline ::google::protobuf::int32 CommonProp::radius() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.radius)
  return radius_;
}
inline void CommonProp::set_radius(::google::protobuf::int32 value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.radius)
}

// optional int32 height = 5;
inline bool CommonProp::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonProp::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonProp::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonProp::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 CommonProp::height() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.height)
  return height_;
}
inline void CommonProp::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.height)
}

// optional int32 level = 6;
inline bool CommonProp::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommonProp::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommonProp::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommonProp::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 CommonProp::level() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.level)
  return level_;
}
inline void CommonProp::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.level)
}

// optional int32 gender = 7;
inline bool CommonProp::has_gender() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommonProp::set_has_gender() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommonProp::clear_has_gender() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommonProp::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ::google::protobuf::int32 CommonProp::gender() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.gender)
  return gender_;
}
inline void CommonProp::set_gender(::google::protobuf::int32 value) {
  set_has_gender();
  gender_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.gender)
}

// optional int32 profession = 8;
inline bool CommonProp::has_profession() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommonProp::set_has_profession() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommonProp::clear_has_profession() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommonProp::clear_profession() {
  profession_ = 0;
  clear_has_profession();
}
inline ::google::protobuf::int32 CommonProp::profession() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.profession)
  return profession_;
}
inline void CommonProp::set_profession(::google::protobuf::int32 value) {
  set_has_profession();
  profession_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.profession)
}

// optional int32 speed = 9;
inline bool CommonProp::has_speed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommonProp::set_has_speed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommonProp::clear_has_speed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommonProp::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 CommonProp::speed() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.speed)
  return speed_;
}
inline void CommonProp::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.speed)
}

// optional int32 hp = 10;
inline bool CommonProp::has_hp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CommonProp::set_has_hp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CommonProp::clear_has_hp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CommonProp::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 CommonProp::hp() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.hp)
  return hp_;
}
inline void CommonProp::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.hp)
}

// optional int32 mp = 11;
inline bool CommonProp::has_mp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CommonProp::set_has_mp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CommonProp::clear_has_mp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CommonProp::clear_mp() {
  mp_ = 0;
  clear_has_mp();
}
inline ::google::protobuf::int32 CommonProp::mp() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.mp)
  return mp_;
}
inline void CommonProp::set_mp(::google::protobuf::int32 value) {
  set_has_mp();
  mp_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.mp)
}

// optional int32 orientation_x = 12;
inline bool CommonProp::has_orientation_x() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CommonProp::set_has_orientation_x() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CommonProp::clear_has_orientation_x() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CommonProp::clear_orientation_x() {
  orientation_x_ = 0;
  clear_has_orientation_x();
}
inline ::google::protobuf::int32 CommonProp::orientation_x() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.orientation_x)
  return orientation_x_;
}
inline void CommonProp::set_orientation_x(::google::protobuf::int32 value) {
  set_has_orientation_x();
  orientation_x_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.orientation_x)
}

// optional int32 orientation_y = 13;
inline bool CommonProp::has_orientation_y() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CommonProp::set_has_orientation_y() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CommonProp::clear_has_orientation_y() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CommonProp::clear_orientation_y() {
  orientation_y_ = 0;
  clear_has_orientation_y();
}
inline ::google::protobuf::int32 CommonProp::orientation_y() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.orientation_y)
  return orientation_y_;
}
inline void CommonProp::set_orientation_y(::google::protobuf::int32 value) {
  set_has_orientation_y();
  orientation_y_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.orientation_y)
}

// optional int32 scene_id = 14;
inline bool CommonProp::has_scene_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CommonProp::set_has_scene_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CommonProp::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CommonProp::clear_scene_id() {
  scene_id_ = 0;
  clear_has_scene_id();
}
inline ::google::protobuf::int32 CommonProp::scene_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.scene_id)
  return scene_id_;
}
inline void CommonProp::set_scene_id(::google::protobuf::int32 value) {
  set_has_scene_id();
  scene_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.scene_id)
}

// optional .Adoter.Asset.Vector3 position = 15;
inline bool CommonProp::has_position() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CommonProp::set_has_position() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CommonProp::clear_has_position() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CommonProp::clear_position() {
  if (position_ != NULL) position_->::Adoter::Asset::Vector3::Clear();
  clear_has_position();
}
inline const ::Adoter::Asset::Vector3& CommonProp::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Adoter::Asset::Vector3* CommonProp::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Adoter::Asset::Vector3;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonProp.position)
  return position_;
}
inline ::Adoter::Asset::Vector3* CommonProp::release_position() {
  clear_has_position();
  ::Adoter::Asset::Vector3* temp = position_;
  position_ = NULL;
  return temp;
}
inline void CommonProp::set_allocated_position(::Adoter::Asset::Vector3* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CommonProp.position)
}

// optional float visibility_range = 16 [default = 90];
inline bool CommonProp::has_visibility_range() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CommonProp::set_has_visibility_range() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CommonProp::clear_has_visibility_range() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CommonProp::clear_visibility_range() {
  visibility_range_ = 90;
  clear_has_visibility_range();
}
inline float CommonProp::visibility_range() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.visibility_range)
  return visibility_range_;
}
inline void CommonProp::set_visibility_range(float value) {
  set_has_visibility_range();
  visibility_range_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.visibility_range)
}

// optional .Adoter.Asset.CAMP_TYPE camp_type = 17;
inline bool CommonProp::has_camp_type() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CommonProp::set_has_camp_type() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CommonProp::clear_has_camp_type() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CommonProp::clear_camp_type() {
  camp_type_ = 1;
  clear_has_camp_type();
}
inline ::Adoter::Asset::CAMP_TYPE CommonProp::camp_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.camp_type)
  return static_cast< ::Adoter::Asset::CAMP_TYPE >(camp_type_);
}
inline void CommonProp::set_camp_type(::Adoter::Asset::CAMP_TYPE value) {
  assert(::Adoter::Asset::CAMP_TYPE_IsValid(value));
  set_has_camp_type();
  camp_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.camp_type)
}

// optional int32 skills_count = 18 [default = 4];
inline bool CommonProp::has_skills_count() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CommonProp::set_has_skills_count() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CommonProp::clear_has_skills_count() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CommonProp::clear_skills_count() {
  skills_count_ = 4;
  clear_has_skills_count();
}
inline ::google::protobuf::int32 CommonProp::skills_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.skills_count)
  return skills_count_;
}
inline void CommonProp::set_skills_count(::google::protobuf::int32 value) {
  set_has_skills_count();
  skills_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.skills_count)
}

// repeated int32 skills = 19;
inline int CommonProp::skills_size() const {
  return skills_.size();
}
inline void CommonProp::clear_skills() {
  skills_.Clear();
}
inline ::google::protobuf::int32 CommonProp::skills(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.skills)
  return skills_.Get(index);
}
inline void CommonProp::set_skills(int index, ::google::protobuf::int32 value) {
  skills_.Set(index, value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.skills)
}
inline void CommonProp::add_skills(::google::protobuf::int32 value) {
  skills_.Add(value);
  // @@protoc_insertion_point(field_add:Adoter.Asset.CommonProp.skills)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CommonProp::skills() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.CommonProp.skills)
  return skills_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CommonProp::mutable_skills() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.CommonProp.skills)
  return &skills_;
}

// optional int32 level_up_id = 20;
inline bool CommonProp::has_level_up_id() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CommonProp::set_has_level_up_id() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CommonProp::clear_has_level_up_id() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CommonProp::clear_level_up_id() {
  level_up_id_ = 0;
  clear_has_level_up_id();
}
inline ::google::protobuf::int32 CommonProp::level_up_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonProp.level_up_id)
  return level_up_id_;
}
inline void CommonProp::set_level_up_id(::google::protobuf::int32 value) {
  set_has_level_up_id();
  level_up_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonProp.level_up_id)
}

// -------------------------------------------------------------------

// AssetCommonProp

// required int64 global_id = 1;
inline bool AssetCommonProp::has_global_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssetCommonProp::set_has_global_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssetCommonProp::clear_has_global_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssetCommonProp::clear_global_id() {
  global_id_ = GOOGLE_LONGLONG(0);
  clear_has_global_id();
}
inline ::google::protobuf::int64 AssetCommonProp::global_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AssetCommonProp.global_id)
  return global_id_;
}
inline void AssetCommonProp::set_global_id(::google::protobuf::int64 value) {
  set_has_global_id();
  global_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.AssetCommonProp.global_id)
}

// required int32 index = 2;
inline bool AssetCommonProp::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssetCommonProp::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssetCommonProp::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssetCommonProp::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 AssetCommonProp::index() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AssetCommonProp.index)
  return index_;
}
inline void AssetCommonProp::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.AssetCommonProp.index)
}

// required .Adoter.Asset.VERSION_TYPE version = 3;
inline bool AssetCommonProp::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AssetCommonProp::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AssetCommonProp::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AssetCommonProp::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::Adoter::Asset::VERSION_TYPE AssetCommonProp::version() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AssetCommonProp.version)
  return static_cast< ::Adoter::Asset::VERSION_TYPE >(version_);
}
inline void AssetCommonProp::set_version(::Adoter::Asset::VERSION_TYPE value) {
  assert(::Adoter::Asset::VERSION_TYPE_IsValid(value));
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.AssetCommonProp.version)
}

// optional string name = 4;
inline bool AssetCommonProp::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AssetCommonProp::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AssetCommonProp::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AssetCommonProp::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AssetCommonProp::name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AssetCommonProp.name)
  return *name_;
}
inline void AssetCommonProp::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.AssetCommonProp.name)
}
inline void AssetCommonProp::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.AssetCommonProp.name)
}
inline void AssetCommonProp::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.AssetCommonProp.name)
}
inline ::std::string* AssetCommonProp::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.AssetCommonProp.name)
  return name_;
}
inline ::std::string* AssetCommonProp::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AssetCommonProp::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.AssetCommonProp.name)
}

// optional string show_name = 5;
inline bool AssetCommonProp::has_show_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AssetCommonProp::set_has_show_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AssetCommonProp::clear_has_show_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AssetCommonProp::clear_show_name() {
  if (show_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_->clear();
  }
  clear_has_show_name();
}
inline const ::std::string& AssetCommonProp::show_name() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.AssetCommonProp.show_name)
  return *show_name_;
}
inline void AssetCommonProp::set_show_name(const ::std::string& value) {
  set_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_ = new ::std::string;
  }
  show_name_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.AssetCommonProp.show_name)
}
inline void AssetCommonProp::set_show_name(const char* value) {
  set_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_ = new ::std::string;
  }
  show_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.AssetCommonProp.show_name)
}
inline void AssetCommonProp::set_show_name(const char* value, size_t size) {
  set_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_ = new ::std::string;
  }
  show_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.AssetCommonProp.show_name)
}
inline ::std::string* AssetCommonProp::mutable_show_name() {
  set_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.AssetCommonProp.show_name)
  return show_name_;
}
inline ::std::string* AssetCommonProp::release_show_name() {
  clear_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = show_name_;
    show_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AssetCommonProp::set_allocated_show_name(::std::string* show_name) {
  if (show_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete show_name_;
  }
  if (show_name) {
    set_has_show_name();
    show_name_ = show_name;
  } else {
    clear_has_show_name();
    show_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.AssetCommonProp.show_name)
}

// -------------------------------------------------------------------

// Plant

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_PLANT];
inline bool Plant::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Plant::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Plant::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Plant::clear_type_t() {
  type_t_ = 2;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Plant::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Plant.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Plant::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Plant.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool Plant::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Plant::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Plant::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Plant::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& Plant::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Plant.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Plant::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Plant.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Plant::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Plant::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Plant.common_prop)
}

// -------------------------------------------------------------------

// CommonLimit

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COMMON_LIMIT];
inline bool CommonLimit::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonLimit::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonLimit::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonLimit::clear_type_t() {
  type_t_ = 3;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE CommonLimit::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonLimit.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void CommonLimit::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonLimit.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool CommonLimit::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonLimit::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonLimit::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonLimit::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& CommonLimit::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonLimit.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CommonLimit::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CommonLimit.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CommonLimit::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void CommonLimit::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CommonLimit.common_prop)
}

// optional .Adoter.Asset.CommonLimit.COMMON_LIMIT_TYPE limit_type = 3;
inline bool CommonLimit::has_limit_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonLimit::set_has_limit_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonLimit::clear_has_limit_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonLimit::clear_limit_type() {
  limit_type_ = 1;
  clear_has_limit_type();
}
inline ::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE CommonLimit::limit_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonLimit.limit_type)
  return static_cast< ::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE >(limit_type_);
}
inline void CommonLimit::set_limit_type(::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE value) {
  assert(::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE_IsValid(value));
  set_has_limit_type();
  limit_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonLimit.limit_type)
}

// optional .Adoter.Asset.CommonLimit.COOL_DOWN_TYPE cool_down_type = 4;
inline bool CommonLimit::has_cool_down_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonLimit::set_has_cool_down_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonLimit::clear_has_cool_down_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonLimit::clear_cool_down_type() {
  cool_down_type_ = 1;
  clear_has_cool_down_type();
}
inline ::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE CommonLimit::cool_down_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CommonLimit.cool_down_type)
  return static_cast< ::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE >(cool_down_type_);
}
inline void CommonLimit::set_cool_down_type(::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE value) {
  assert(::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE_IsValid(value));
  set_has_cool_down_type();
  cool_down_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CommonLimit.cool_down_type)
}

// -------------------------------------------------------------------

// CoolDown

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_COOL_DOWN];
inline bool CoolDown::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoolDown::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoolDown::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoolDown::clear_type_t() {
  type_t_ = 5;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE CoolDown::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CoolDown.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void CoolDown::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CoolDown.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool CoolDown::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoolDown::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoolDown::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoolDown::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& CoolDown::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CoolDown.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CoolDown::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.CoolDown.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* CoolDown::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void CoolDown::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.CoolDown.common_prop)
}

// optional int32 time = 3;
inline bool CoolDown::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoolDown::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoolDown::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoolDown::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 CoolDown::time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.CoolDown.time)
  return time_;
}
inline void CoolDown::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.CoolDown.time)
}

// -------------------------------------------------------------------

// Hoster

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_HOSTER];
inline bool Hoster::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hoster::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hoster::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hoster::clear_type_t() {
  type_t_ = 6;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Hoster::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Hoster.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Hoster::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Hoster.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool Hoster::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hoster::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hoster::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hoster::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& Hoster::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Hoster.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Hoster::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Hoster.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Hoster::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Hoster::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Hoster.common_prop)
}

// optional .Adoter.Asset.CommonProp human_prop = 3;
inline bool Hoster::has_human_prop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hoster::set_has_human_prop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hoster::clear_has_human_prop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hoster::clear_human_prop() {
  if (human_prop_ != NULL) human_prop_->::Adoter::Asset::CommonProp::Clear();
  clear_has_human_prop();
}
inline const ::Adoter::Asset::CommonProp& Hoster::human_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Hoster.human_prop)
  return human_prop_ != NULL ? *human_prop_ : *default_instance_->human_prop_;
}
inline ::Adoter::Asset::CommonProp* Hoster::mutable_human_prop() {
  set_has_human_prop();
  if (human_prop_ == NULL) human_prop_ = new ::Adoter::Asset::CommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Hoster.human_prop)
  return human_prop_;
}
inline ::Adoter::Asset::CommonProp* Hoster::release_human_prop() {
  clear_has_human_prop();
  ::Adoter::Asset::CommonProp* temp = human_prop_;
  human_prop_ = NULL;
  return temp;
}
inline void Hoster::set_allocated_human_prop(::Adoter::Asset::CommonProp* human_prop) {
  delete human_prop_;
  human_prop_ = human_prop;
  if (human_prop) {
    set_has_human_prop();
  } else {
    clear_has_human_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Hoster.human_prop)
}

// optional string behaviac_tree_path = 4;
inline bool Hoster::has_behaviac_tree_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hoster::set_has_behaviac_tree_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hoster::clear_has_behaviac_tree_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hoster::clear_behaviac_tree_path() {
  if (behaviac_tree_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_->clear();
  }
  clear_has_behaviac_tree_path();
}
inline const ::std::string& Hoster::behaviac_tree_path() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Hoster.behaviac_tree_path)
  return *behaviac_tree_path_;
}
inline void Hoster::set_behaviac_tree_path(const ::std::string& value) {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  behaviac_tree_path_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Hoster.behaviac_tree_path)
}
inline void Hoster::set_behaviac_tree_path(const char* value) {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  behaviac_tree_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Hoster.behaviac_tree_path)
}
inline void Hoster::set_behaviac_tree_path(const char* value, size_t size) {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  behaviac_tree_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Hoster.behaviac_tree_path)
}
inline ::std::string* Hoster::mutable_behaviac_tree_path() {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Hoster.behaviac_tree_path)
  return behaviac_tree_path_;
}
inline ::std::string* Hoster::release_behaviac_tree_path() {
  clear_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = behaviac_tree_path_;
    behaviac_tree_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Hoster::set_allocated_behaviac_tree_path(::std::string* behaviac_tree_path) {
  if (behaviac_tree_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete behaviac_tree_path_;
  }
  if (behaviac_tree_path) {
    set_has_behaviac_tree_path();
    behaviac_tree_path_ = behaviac_tree_path;
  } else {
    clear_has_behaviac_tree_path();
    behaviac_tree_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Hoster.behaviac_tree_path)
}

// optional int32 build_time = 5;
inline bool Hoster::has_build_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Hoster::set_has_build_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Hoster::clear_has_build_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Hoster::clear_build_time() {
  build_time_ = 0;
  clear_has_build_time();
}
inline ::google::protobuf::int32 Hoster::build_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Hoster.build_time)
  return build_time_;
}
inline void Hoster::set_build_time(::google::protobuf::int32 value) {
  set_has_build_time();
  build_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Hoster.build_time)
}

// optional int32 attack_speed = 6;
inline bool Hoster::has_attack_speed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Hoster::set_has_attack_speed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Hoster::clear_has_attack_speed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Hoster::clear_attack_speed() {
  attack_speed_ = 0;
  clear_has_attack_speed();
}
inline ::google::protobuf::int32 Hoster::attack_speed() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Hoster.attack_speed)
  return attack_speed_;
}
inline void Hoster::set_attack_speed(::google::protobuf::int32 value) {
  set_has_attack_speed();
  attack_speed_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Hoster.attack_speed)
}

// optional int32 produce_entity_id = 7;
inline bool Hoster::has_produce_entity_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Hoster::set_has_produce_entity_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Hoster::clear_has_produce_entity_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Hoster::clear_produce_entity_id() {
  produce_entity_id_ = 0;
  clear_has_produce_entity_id();
}
inline ::google::protobuf::int32 Hoster::produce_entity_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Hoster.produce_entity_id)
  return produce_entity_id_;
}
inline void Hoster::set_produce_entity_id(::google::protobuf::int32 value) {
  set_has_produce_entity_id();
  produce_entity_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Hoster.produce_entity_id)
}

// optional int32 produce_entity_speed = 8;
inline bool Hoster::has_produce_entity_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Hoster::set_has_produce_entity_speed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Hoster::clear_has_produce_entity_speed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Hoster::clear_produce_entity_speed() {
  produce_entity_speed_ = 0;
  clear_has_produce_entity_speed();
}
inline ::google::protobuf::int32 Hoster::produce_entity_speed() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Hoster.produce_entity_speed)
  return produce_entity_speed_;
}
inline void Hoster::set_produce_entity_speed(::google::protobuf::int32 value) {
  set_has_produce_entity_speed();
  produce_entity_speed_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Hoster.produce_entity_speed)
}

// optional int32 produce_entity_count = 9;
inline bool Hoster::has_produce_entity_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Hoster::set_has_produce_entity_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Hoster::clear_has_produce_entity_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Hoster::clear_produce_entity_count() {
  produce_entity_count_ = 0;
  clear_has_produce_entity_count();
}
inline ::google::protobuf::int32 Hoster::produce_entity_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Hoster.produce_entity_count)
  return produce_entity_count_;
}
inline void Hoster::set_produce_entity_count(::google::protobuf::int32 value) {
  set_has_produce_entity_count();
  produce_entity_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Hoster.produce_entity_count)
}

// -------------------------------------------------------------------

// Harm

// optional .Adoter.Asset.Harm.HARM_TYPE harm_type = 1;
inline bool Harm::has_harm_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Harm::set_has_harm_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Harm::clear_has_harm_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Harm::clear_harm_type() {
  harm_type_ = 1;
  clear_has_harm_type();
}
inline ::Adoter::Asset::Harm_HARM_TYPE Harm::harm_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Harm.harm_type)
  return static_cast< ::Adoter::Asset::Harm_HARM_TYPE >(harm_type_);
}
inline void Harm::set_harm_type(::Adoter::Asset::Harm_HARM_TYPE value) {
  assert(::Adoter::Asset::Harm_HARM_TYPE_IsValid(value));
  set_has_harm_type();
  harm_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Harm.harm_type)
}

// optional int32 harm_total = 2;
inline bool Harm::has_harm_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Harm::set_has_harm_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Harm::clear_has_harm_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Harm::clear_harm_total() {
  harm_total_ = 0;
  clear_has_harm_total();
}
inline ::google::protobuf::int32 Harm::harm_total() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Harm.harm_total)
  return harm_total_;
}
inline void Harm::set_harm_total(::google::protobuf::int32 value) {
  set_has_harm_total();
  harm_total_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Harm.harm_total)
}

// optional int32 last_time = 3;
inline bool Harm::has_last_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Harm::set_has_last_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Harm::clear_has_last_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Harm::clear_last_time() {
  last_time_ = 0;
  clear_has_last_time();
}
inline ::google::protobuf::int32 Harm::last_time() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Harm.last_time)
  return last_time_;
}
inline void Harm::set_last_time(::google::protobuf::int32 value) {
  set_has_last_time();
  last_time_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Harm.last_time)
}

// optional int32 harm_per_second = 4;
inline bool Harm::has_harm_per_second() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Harm::set_has_harm_per_second() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Harm::clear_has_harm_per_second() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Harm::clear_harm_per_second() {
  harm_per_second_ = 0;
  clear_has_harm_per_second();
}
inline ::google::protobuf::int32 Harm::harm_per_second() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Harm.harm_per_second)
  return harm_per_second_;
}
inline void Harm::set_harm_per_second(::google::protobuf::int32 value) {
  set_has_harm_per_second();
  harm_per_second_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Harm.harm_per_second)
}

// optional int32 harm_range = 5;
inline bool Harm::has_harm_range() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Harm::set_has_harm_range() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Harm::clear_has_harm_range() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Harm::clear_harm_range() {
  harm_range_ = 0;
  clear_has_harm_range();
}
inline ::google::protobuf::int32 Harm::harm_range() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Harm.harm_range)
  return harm_range_;
}
inline void Harm::set_harm_range(::google::protobuf::int32 value) {
  set_has_harm_range();
  harm_range_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Harm.harm_range)
}

// optional .Adoter.Asset.ENTITY_TYPE harm_target = 6;
inline bool Harm::has_harm_target() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Harm::set_has_harm_target() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Harm::clear_has_harm_target() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Harm::clear_harm_target() {
  harm_target_ = 1;
  clear_has_harm_target();
}
inline ::Adoter::Asset::ENTITY_TYPE Harm::harm_target() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Harm.harm_target)
  return static_cast< ::Adoter::Asset::ENTITY_TYPE >(harm_target_);
}
inline void Harm::set_harm_target(::Adoter::Asset::ENTITY_TYPE value) {
  assert(::Adoter::Asset::ENTITY_TYPE_IsValid(value));
  set_has_harm_target();
  harm_target_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Harm.harm_target)
}

// -------------------------------------------------------------------

// Skill

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_SKILL];
inline bool Skill::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Skill::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Skill::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Skill::clear_type_t() {
  type_t_ = 7;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Skill::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Skill.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Skill::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Skill.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool Skill::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Skill::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Skill::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Skill::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& Skill::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Skill.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Skill::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Skill.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Skill::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Skill::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Skill.common_prop)
}

// optional int32 level = 3;
inline bool Skill::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Skill::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Skill::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Skill::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 Skill::level() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Skill.level)
  return level_;
}
inline void Skill::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Skill.level)
}

// optional string behaviac_tree_path = 4;
inline bool Skill::has_behaviac_tree_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Skill::set_has_behaviac_tree_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Skill::clear_has_behaviac_tree_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Skill::clear_behaviac_tree_path() {
  if (behaviac_tree_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_->clear();
  }
  clear_has_behaviac_tree_path();
}
inline const ::std::string& Skill::behaviac_tree_path() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Skill.behaviac_tree_path)
  return *behaviac_tree_path_;
}
inline void Skill::set_behaviac_tree_path(const ::std::string& value) {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  behaviac_tree_path_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Skill.behaviac_tree_path)
}
inline void Skill::set_behaviac_tree_path(const char* value) {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  behaviac_tree_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Skill.behaviac_tree_path)
}
inline void Skill::set_behaviac_tree_path(const char* value, size_t size) {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  behaviac_tree_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Skill.behaviac_tree_path)
}
inline ::std::string* Skill::mutable_behaviac_tree_path() {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Skill.behaviac_tree_path)
  return behaviac_tree_path_;
}
inline ::std::string* Skill::release_behaviac_tree_path() {
  clear_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = behaviac_tree_path_;
    behaviac_tree_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Skill::set_allocated_behaviac_tree_path(::std::string* behaviac_tree_path) {
  if (behaviac_tree_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete behaviac_tree_path_;
  }
  if (behaviac_tree_path) {
    set_has_behaviac_tree_path();
    behaviac_tree_path_ = behaviac_tree_path;
  } else {
    clear_has_behaviac_tree_path();
    behaviac_tree_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Skill.behaviac_tree_path)
}

// optional int32 cool_down_id = 5;
inline bool Skill::has_cool_down_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Skill::set_has_cool_down_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Skill::clear_has_cool_down_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Skill::clear_cool_down_id() {
  cool_down_id_ = 0;
  clear_has_cool_down_id();
}
inline ::google::protobuf::int32 Skill::cool_down_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Skill.cool_down_id)
  return cool_down_id_;
}
inline void Skill::set_cool_down_id(::google::protobuf::int32 value) {
  set_has_cool_down_id();
  cool_down_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Skill.cool_down_id)
}

// optional int32 defense = 6;
inline bool Skill::has_defense() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Skill::set_has_defense() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Skill::clear_has_defense() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Skill::clear_defense() {
  defense_ = 0;
  clear_has_defense();
}
inline ::google::protobuf::int32 Skill::defense() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Skill.defense)
  return defense_;
}
inline void Skill::set_defense(::google::protobuf::int32 value) {
  set_has_defense();
  defense_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Skill.defense)
}

// optional .Adoter.Asset.Harm harm = 7;
inline bool Skill::has_harm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Skill::set_has_harm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Skill::clear_has_harm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Skill::clear_harm() {
  if (harm_ != NULL) harm_->::Adoter::Asset::Harm::Clear();
  clear_has_harm();
}
inline const ::Adoter::Asset::Harm& Skill::harm() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Skill.harm)
  return harm_ != NULL ? *harm_ : *default_instance_->harm_;
}
inline ::Adoter::Asset::Harm* Skill::mutable_harm() {
  set_has_harm();
  if (harm_ == NULL) harm_ = new ::Adoter::Asset::Harm;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Skill.harm)
  return harm_;
}
inline ::Adoter::Asset::Harm* Skill::release_harm() {
  clear_has_harm();
  ::Adoter::Asset::Harm* temp = harm_;
  harm_ = NULL;
  return temp;
}
inline void Skill::set_allocated_harm(::Adoter::Asset::Harm* harm) {
  delete harm_;
  harm_ = harm;
  if (harm) {
    set_has_harm();
  } else {
    clear_has_harm();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Skill.harm)
}

// optional int32 summon_entity_id = 8;
inline bool Skill::has_summon_entity_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Skill::set_has_summon_entity_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Skill::clear_has_summon_entity_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Skill::clear_summon_entity_id() {
  summon_entity_id_ = 0;
  clear_has_summon_entity_id();
}
inline ::google::protobuf::int32 Skill::summon_entity_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Skill.summon_entity_id)
  return summon_entity_id_;
}
inline void Skill::set_summon_entity_id(::google::protobuf::int32 value) {
  set_has_summon_entity_id();
  summon_entity_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Skill.summon_entity_id)
}

// optional int32 death_harm_total = 9;
inline bool Skill::has_death_harm_total() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Skill::set_has_death_harm_total() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Skill::clear_has_death_harm_total() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Skill::clear_death_harm_total() {
  death_harm_total_ = 0;
  clear_has_death_harm_total();
}
inline ::google::protobuf::int32 Skill::death_harm_total() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Skill.death_harm_total)
  return death_harm_total_;
}
inline void Skill::set_death_harm_total(::google::protobuf::int32 value) {
  set_has_death_harm_total();
  death_harm_total_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Skill.death_harm_total)
}

// -------------------------------------------------------------------

// LevelUpCurve_Consume

// optional int32 level_up = 1;
inline bool LevelUpCurve_Consume::has_level_up() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LevelUpCurve_Consume::set_has_level_up() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LevelUpCurve_Consume::clear_has_level_up() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LevelUpCurve_Consume::clear_level_up() {
  level_up_ = 0;
  clear_has_level_up();
}
inline ::google::protobuf::int32 LevelUpCurve_Consume::level_up() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LevelUpCurve.Consume.level_up)
  return level_up_;
}
inline void LevelUpCurve_Consume::set_level_up(::google::protobuf::int32 value) {
  set_has_level_up();
  level_up_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LevelUpCurve.Consume.level_up)
}

// optional .Adoter.Asset.LevelUpCurve.Consume.CONSUME_TYPE consume_type = 2;
inline bool LevelUpCurve_Consume::has_consume_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LevelUpCurve_Consume::set_has_consume_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LevelUpCurve_Consume::clear_has_consume_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LevelUpCurve_Consume::clear_consume_type() {
  consume_type_ = 1;
  clear_has_consume_type();
}
inline ::Adoter::Asset::LevelUpCurve_Consume_CONSUME_TYPE LevelUpCurve_Consume::consume_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LevelUpCurve.Consume.consume_type)
  return static_cast< ::Adoter::Asset::LevelUpCurve_Consume_CONSUME_TYPE >(consume_type_);
}
inline void LevelUpCurve_Consume::set_consume_type(::Adoter::Asset::LevelUpCurve_Consume_CONSUME_TYPE value) {
  assert(::Adoter::Asset::LevelUpCurve_Consume_CONSUME_TYPE_IsValid(value));
  set_has_consume_type();
  consume_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LevelUpCurve.Consume.consume_type)
}

// optional int32 consume_value = 3;
inline bool LevelUpCurve_Consume::has_consume_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LevelUpCurve_Consume::set_has_consume_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LevelUpCurve_Consume::clear_has_consume_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LevelUpCurve_Consume::clear_consume_value() {
  consume_value_ = 0;
  clear_has_consume_value();
}
inline ::google::protobuf::int32 LevelUpCurve_Consume::consume_value() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LevelUpCurve.Consume.consume_value)
  return consume_value_;
}
inline void LevelUpCurve_Consume::set_consume_value(::google::protobuf::int32 value) {
  set_has_consume_value();
  consume_value_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LevelUpCurve.Consume.consume_value)
}

// -------------------------------------------------------------------

// LevelUpCurve

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_LEVEL_UP];
inline bool LevelUpCurve::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LevelUpCurve::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LevelUpCurve::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LevelUpCurve::clear_type_t() {
  type_t_ = 8;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE LevelUpCurve::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LevelUpCurve.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void LevelUpCurve::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LevelUpCurve.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool LevelUpCurve::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LevelUpCurve::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LevelUpCurve::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LevelUpCurve::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& LevelUpCurve::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LevelUpCurve.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* LevelUpCurve::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.LevelUpCurve.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* LevelUpCurve::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void LevelUpCurve::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.LevelUpCurve.common_prop)
}

// optional int32 consumes_count = 3 [default = 20];
inline bool LevelUpCurve::has_consumes_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LevelUpCurve::set_has_consumes_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LevelUpCurve::clear_has_consumes_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LevelUpCurve::clear_consumes_count() {
  consumes_count_ = 20;
  clear_has_consumes_count();
}
inline ::google::protobuf::int32 LevelUpCurve::consumes_count() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LevelUpCurve.consumes_count)
  return consumes_count_;
}
inline void LevelUpCurve::set_consumes_count(::google::protobuf::int32 value) {
  set_has_consumes_count();
  consumes_count_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.LevelUpCurve.consumes_count)
}

// repeated .Adoter.Asset.LevelUpCurve.Consume consumes = 4;
inline int LevelUpCurve::consumes_size() const {
  return consumes_.size();
}
inline void LevelUpCurve::clear_consumes() {
  consumes_.Clear();
}
inline const ::Adoter::Asset::LevelUpCurve_Consume& LevelUpCurve::consumes(int index) const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.LevelUpCurve.consumes)
  return consumes_.Get(index);
}
inline ::Adoter::Asset::LevelUpCurve_Consume* LevelUpCurve::mutable_consumes(int index) {
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.LevelUpCurve.consumes)
  return consumes_.Mutable(index);
}
inline ::Adoter::Asset::LevelUpCurve_Consume* LevelUpCurve::add_consumes() {
  // @@protoc_insertion_point(field_add:Adoter.Asset.LevelUpCurve.consumes)
  return consumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LevelUpCurve_Consume >&
LevelUpCurve::consumes() const {
  // @@protoc_insertion_point(field_list:Adoter.Asset.LevelUpCurve.consumes)
  return consumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::Adoter::Asset::LevelUpCurve_Consume >*
LevelUpCurve::mutable_consumes() {
  // @@protoc_insertion_point(field_mutable_list:Adoter.Asset.LevelUpCurve.consumes)
  return &consumes_;
}

// -------------------------------------------------------------------

// Scene

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_SCENE];
inline bool Scene::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scene::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Scene::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Scene::clear_type_t() {
  type_t_ = 9;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Scene::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Scene.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Scene::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Scene.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool Scene::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Scene::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Scene::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Scene::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& Scene::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Scene.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Scene::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Scene.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Scene::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Scene::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Scene.common_prop)
}

// optional int32 length = 3;
inline bool Scene::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Scene::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Scene::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Scene::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 Scene::length() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Scene.length)
  return length_;
}
inline void Scene::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Scene.length)
}

// optional int32 width = 4;
inline bool Scene::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Scene::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Scene::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Scene::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Scene::width() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Scene.width)
  return width_;
}
inline void Scene::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Scene.width)
}

// optional string terrain_path = 5;
inline bool Scene::has_terrain_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Scene::set_has_terrain_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Scene::clear_has_terrain_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Scene::clear_terrain_path() {
  if (terrain_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    terrain_path_->clear();
  }
  clear_has_terrain_path();
}
inline const ::std::string& Scene::terrain_path() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Scene.terrain_path)
  return *terrain_path_;
}
inline void Scene::set_terrain_path(const ::std::string& value) {
  set_has_terrain_path();
  if (terrain_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    terrain_path_ = new ::std::string;
  }
  terrain_path_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Scene.terrain_path)
}
inline void Scene::set_terrain_path(const char* value) {
  set_has_terrain_path();
  if (terrain_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    terrain_path_ = new ::std::string;
  }
  terrain_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Scene.terrain_path)
}
inline void Scene::set_terrain_path(const char* value, size_t size) {
  set_has_terrain_path();
  if (terrain_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    terrain_path_ = new ::std::string;
  }
  terrain_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Scene.terrain_path)
}
inline ::std::string* Scene::mutable_terrain_path() {
  set_has_terrain_path();
  if (terrain_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    terrain_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Scene.terrain_path)
  return terrain_path_;
}
inline ::std::string* Scene::release_terrain_path() {
  clear_has_terrain_path();
  if (terrain_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = terrain_path_;
    terrain_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Scene::set_allocated_terrain_path(::std::string* terrain_path) {
  if (terrain_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete terrain_path_;
  }
  if (terrain_path) {
    set_has_terrain_path();
    terrain_path_ = terrain_path;
  } else {
    clear_has_terrain_path();
    terrain_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Scene.terrain_path)
}

// -------------------------------------------------------------------

// Particle

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ASSET_TYPE_PARTICLE];
inline bool Particle::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Particle::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Particle::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Particle::clear_type_t() {
  type_t_ = 10;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Particle::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Particle.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Particle::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Particle.type_t)
}

// optional .Adoter.Asset.AssetCommonProp common_prop = 2;
inline bool Particle::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Particle::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Particle::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Particle::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& Particle::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Particle.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Particle::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Particle.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Particle::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Particle::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Particle.common_prop)
}

// optional .Adoter.Asset.ENTITY_TYPE entity_type = 3;
inline bool Particle::has_entity_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Particle::set_has_entity_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Particle::clear_has_entity_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Particle::clear_entity_type() {
  entity_type_ = 1;
  clear_has_entity_type();
}
inline ::Adoter::Asset::ENTITY_TYPE Particle::entity_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Particle.entity_type)
  return static_cast< ::Adoter::Asset::ENTITY_TYPE >(entity_type_);
}
inline void Particle::set_entity_type(::Adoter::Asset::ENTITY_TYPE value) {
  assert(::Adoter::Asset::ENTITY_TYPE_IsValid(value));
  set_has_entity_type();
  entity_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Particle.entity_type)
}

// optional int32 speed = 4;
inline bool Particle::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Particle::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Particle::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Particle::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 Particle::speed() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Particle.speed)
  return speed_;
}
inline void Particle::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Particle.speed)
}

// optional int32 orientation_x = 5;
inline bool Particle::has_orientation_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Particle::set_has_orientation_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Particle::clear_has_orientation_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Particle::clear_orientation_x() {
  orientation_x_ = 0;
  clear_has_orientation_x();
}
inline ::google::protobuf::int32 Particle::orientation_x() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Particle.orientation_x)
  return orientation_x_;
}
inline void Particle::set_orientation_x(::google::protobuf::int32 value) {
  set_has_orientation_x();
  orientation_x_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Particle.orientation_x)
}

// optional int32 orientation_y = 6;
inline bool Particle::has_orientation_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Particle::set_has_orientation_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Particle::clear_has_orientation_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Particle::clear_orientation_y() {
  orientation_y_ = 0;
  clear_has_orientation_y();
}
inline ::google::protobuf::int32 Particle::orientation_y() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Particle.orientation_y)
  return orientation_y_;
}
inline void Particle::set_orientation_y(::google::protobuf::int32 value) {
  set_has_orientation_y();
  orientation_y_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Particle.orientation_y)
}

// optional .Adoter.Asset.Vector3 position = 7;
inline bool Particle::has_position() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Particle::set_has_position() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Particle::clear_has_position() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Particle::clear_position() {
  if (position_ != NULL) position_->::Adoter::Asset::Vector3::Clear();
  clear_has_position();
}
inline const ::Adoter::Asset::Vector3& Particle::position() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Particle.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Adoter::Asset::Vector3* Particle::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Adoter::Asset::Vector3;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Particle.position)
  return position_;
}
inline ::Adoter::Asset::Vector3* Particle::release_position() {
  clear_has_position();
  ::Adoter::Asset::Vector3* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Particle::set_allocated_position(::Adoter::Asset::Vector3* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Particle.position)
}

// -------------------------------------------------------------------

// Item_CommonProp

// optional .Adoter.Asset.AssetCommonProp common_prop = 1;
inline bool Item_CommonProp::has_common_prop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_CommonProp::set_has_common_prop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_CommonProp::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_CommonProp::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::Adoter::Asset::AssetCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::Adoter::Asset::AssetCommonProp& Item_CommonProp::common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Item_CommonProp::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::Adoter::Asset::AssetCommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Item_CommonProp.common_prop)
  return common_prop_;
}
inline ::Adoter::Asset::AssetCommonProp* Item_CommonProp::release_common_prop() {
  clear_has_common_prop();
  ::Adoter::Asset::AssetCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Item_CommonProp::set_allocated_common_prop(::Adoter::Asset::AssetCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Item_CommonProp.common_prop)
}

// optional int32 quality = 2;
inline bool Item_CommonProp::has_quality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_CommonProp::set_has_quality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_CommonProp::clear_has_quality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_CommonProp::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 Item_CommonProp::quality() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.quality)
  return quality_;
}
inline void Item_CommonProp::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.quality)
}

// optional int32 min_level_limit = 3;
inline bool Item_CommonProp::has_min_level_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item_CommonProp::set_has_min_level_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item_CommonProp::clear_has_min_level_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item_CommonProp::clear_min_level_limit() {
  min_level_limit_ = 0;
  clear_has_min_level_limit();
}
inline ::google::protobuf::int32 Item_CommonProp::min_level_limit() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.min_level_limit)
  return min_level_limit_;
}
inline void Item_CommonProp::set_min_level_limit(::google::protobuf::int32 value) {
  set_has_min_level_limit();
  min_level_limit_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.min_level_limit)
}

// optional int32 max_level_limit = 4;
inline bool Item_CommonProp::has_max_level_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Item_CommonProp::set_has_max_level_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Item_CommonProp::clear_has_max_level_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Item_CommonProp::clear_max_level_limit() {
  max_level_limit_ = 0;
  clear_has_max_level_limit();
}
inline ::google::protobuf::int32 Item_CommonProp::max_level_limit() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.max_level_limit)
  return max_level_limit_;
}
inline void Item_CommonProp::set_max_level_limit(::google::protobuf::int32 value) {
  set_has_max_level_limit();
  max_level_limit_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.max_level_limit)
}

// optional int32 pile_max = 5;
inline bool Item_CommonProp::has_pile_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Item_CommonProp::set_has_pile_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Item_CommonProp::clear_has_pile_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Item_CommonProp::clear_pile_max() {
  pile_max_ = 0;
  clear_has_pile_max();
}
inline ::google::protobuf::int32 Item_CommonProp::pile_max() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.pile_max)
  return pile_max_;
}
inline void Item_CommonProp::set_pile_max(::google::protobuf::int32 value) {
  set_has_pile_max();
  pile_max_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.pile_max)
}

// optional int32 batch_use = 6;
inline bool Item_CommonProp::has_batch_use() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Item_CommonProp::set_has_batch_use() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Item_CommonProp::clear_has_batch_use() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Item_CommonProp::clear_batch_use() {
  batch_use_ = 0;
  clear_has_batch_use();
}
inline ::google::protobuf::int32 Item_CommonProp::batch_use() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.batch_use)
  return batch_use_;
}
inline void Item_CommonProp::set_batch_use(::google::protobuf::int32 value) {
  set_has_batch_use();
  batch_use_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.batch_use)
}

// optional int32 auto_use = 7;
inline bool Item_CommonProp::has_auto_use() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Item_CommonProp::set_has_auto_use() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Item_CommonProp::clear_has_auto_use() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Item_CommonProp::clear_auto_use() {
  auto_use_ = 0;
  clear_has_auto_use();
}
inline ::google::protobuf::int32 Item_CommonProp::auto_use() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.auto_use)
  return auto_use_;
}
inline void Item_CommonProp::set_auto_use(::google::protobuf::int32 value) {
  set_has_auto_use();
  auto_use_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.auto_use)
}

// optional int32 cool_down_id = 8;
inline bool Item_CommonProp::has_cool_down_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Item_CommonProp::set_has_cool_down_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Item_CommonProp::clear_has_cool_down_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Item_CommonProp::clear_cool_down_id() {
  cool_down_id_ = 0;
  clear_has_cool_down_id();
}
inline ::google::protobuf::int32 Item_CommonProp::cool_down_id() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.cool_down_id)
  return cool_down_id_;
}
inline void Item_CommonProp::set_cool_down_id(::google::protobuf::int32 value) {
  set_has_cool_down_id();
  cool_down_id_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.cool_down_id)
}

// optional .Adoter.Asset.INVENTORY_TYPE inventory = 9;
inline bool Item_CommonProp::has_inventory() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Item_CommonProp::set_has_inventory() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Item_CommonProp::clear_has_inventory() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Item_CommonProp::clear_inventory() {
  inventory_ = 1;
  clear_has_inventory();
}
inline ::Adoter::Asset::INVENTORY_TYPE Item_CommonProp::inventory() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.inventory)
  return static_cast< ::Adoter::Asset::INVENTORY_TYPE >(inventory_);
}
inline void Item_CommonProp::set_inventory(::Adoter::Asset::INVENTORY_TYPE value) {
  assert(::Adoter::Asset::INVENTORY_TYPE_IsValid(value));
  set_has_inventory();
  inventory_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.inventory)
}

// optional .Adoter.Asset.PROF_TYPE prof_mask = 10;
inline bool Item_CommonProp::has_prof_mask() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Item_CommonProp::set_has_prof_mask() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Item_CommonProp::clear_has_prof_mask() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Item_CommonProp::clear_prof_mask() {
  prof_mask_ = 1;
  clear_has_prof_mask();
}
inline ::Adoter::Asset::PROF_TYPE Item_CommonProp::prof_mask() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_CommonProp.prof_mask)
  return static_cast< ::Adoter::Asset::PROF_TYPE >(prof_mask_);
}
inline void Item_CommonProp::set_prof_mask(::Adoter::Asset::PROF_TYPE value) {
  assert(::Adoter::Asset::PROF_TYPE_IsValid(value));
  set_has_prof_mask();
  prof_mask_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_CommonProp.prof_mask)
}

// -------------------------------------------------------------------

// Item_Item

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_BEGIN];
inline bool Item_Item::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_Item::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_Item::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_Item::clear_type_t() {
  type_t_ = 201;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Item_Item::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Item.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Item_Item::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Item.type_t)
}

// optional bytes stuff = 2;
inline bool Item_Item::has_stuff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_Item::set_has_stuff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_Item::clear_has_stuff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_Item::clear_stuff() {
  if (stuff_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_->clear();
  }
  clear_has_stuff();
}
inline const ::std::string& Item_Item::stuff() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Item.stuff)
  return *stuff_;
}
inline void Item_Item::set_stuff(const ::std::string& value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Item.stuff)
}
inline void Item_Item::set_stuff(const char* value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Item_Item.stuff)
}
inline void Item_Item::set_stuff(const void* value, size_t size) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Item_Item.stuff)
}
inline ::std::string* Item_Item::mutable_stuff() {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Item_Item.stuff)
  return stuff_;
}
inline ::std::string* Item_Item::release_stuff() {
  clear_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stuff_;
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Item_Item::set_allocated_stuff(::std::string* stuff) {
  if (stuff_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stuff_;
  }
  if (stuff) {
    set_has_stuff();
    stuff_ = stuff;
  } else {
    clear_has_stuff();
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Item_Item.stuff)
}

// optional bytes stuff_extra = 3;
inline bool Item_Item::has_stuff_extra() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item_Item::set_has_stuff_extra() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item_Item::clear_has_stuff_extra() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item_Item::clear_stuff_extra() {
  if (stuff_extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_->clear();
  }
  clear_has_stuff_extra();
}
inline const ::std::string& Item_Item::stuff_extra() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Item.stuff_extra)
  return *stuff_extra_;
}
inline void Item_Item::set_stuff_extra(const ::std::string& value) {
  set_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_ = new ::std::string;
  }
  stuff_extra_->assign(value);
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Item.stuff_extra)
}
inline void Item_Item::set_stuff_extra(const char* value) {
  set_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_ = new ::std::string;
  }
  stuff_extra_->assign(value);
  // @@protoc_insertion_point(field_set_char:Adoter.Asset.Item_Item.stuff_extra)
}
inline void Item_Item::set_stuff_extra(const void* value, size_t size) {
  set_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_ = new ::std::string;
  }
  stuff_extra_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Adoter.Asset.Item_Item.stuff_extra)
}
inline ::std::string* Item_Item::mutable_stuff_extra() {
  set_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Item_Item.stuff_extra)
  return stuff_extra_;
}
inline ::std::string* Item_Item::release_stuff_extra() {
  clear_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stuff_extra_;
    stuff_extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Item_Item::set_allocated_stuff_extra(::std::string* stuff_extra) {
  if (stuff_extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stuff_extra_;
  }
  if (stuff_extra) {
    set_has_stuff_extra();
    stuff_extra_ = stuff_extra;
  } else {
    clear_has_stuff_extra();
    stuff_extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Item_Item.stuff_extra)
}

// -------------------------------------------------------------------

// Item_Potion

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_POTION];
inline bool Item_Potion::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_Potion::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_Potion::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_Potion::clear_type_t() {
  type_t_ = 202;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Item_Potion::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Potion.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Item_Potion::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Potion.type_t)
}

// optional .Adoter.Asset.Item_CommonProp item_common_prop = 2;
inline bool Item_Potion::has_item_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_Potion::set_has_item_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_Potion::clear_has_item_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_Potion::clear_item_common_prop() {
  if (item_common_prop_ != NULL) item_common_prop_->::Adoter::Asset::Item_CommonProp::Clear();
  clear_has_item_common_prop();
}
inline const ::Adoter::Asset::Item_CommonProp& Item_Potion::item_common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Potion.item_common_prop)
  return item_common_prop_ != NULL ? *item_common_prop_ : *default_instance_->item_common_prop_;
}
inline ::Adoter::Asset::Item_CommonProp* Item_Potion::mutable_item_common_prop() {
  set_has_item_common_prop();
  if (item_common_prop_ == NULL) item_common_prop_ = new ::Adoter::Asset::Item_CommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Item_Potion.item_common_prop)
  return item_common_prop_;
}
inline ::Adoter::Asset::Item_CommonProp* Item_Potion::release_item_common_prop() {
  clear_has_item_common_prop();
  ::Adoter::Asset::Item_CommonProp* temp = item_common_prop_;
  item_common_prop_ = NULL;
  return temp;
}
inline void Item_Potion::set_allocated_item_common_prop(::Adoter::Asset::Item_CommonProp* item_common_prop) {
  delete item_common_prop_;
  item_common_prop_ = item_common_prop;
  if (item_common_prop) {
    set_has_item_common_prop();
  } else {
    clear_has_item_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Item_Potion.item_common_prop)
}

// optional .Adoter.Asset.Item_Potion.POTION_TYPE potion_type = 3;
inline bool Item_Potion::has_potion_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item_Potion::set_has_potion_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item_Potion::clear_has_potion_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item_Potion::clear_potion_type() {
  potion_type_ = 1;
  clear_has_potion_type();
}
inline ::Adoter::Asset::Item_Potion_POTION_TYPE Item_Potion::potion_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Potion.potion_type)
  return static_cast< ::Adoter::Asset::Item_Potion_POTION_TYPE >(potion_type_);
}
inline void Item_Potion::set_potion_type(::Adoter::Asset::Item_Potion_POTION_TYPE value) {
  assert(::Adoter::Asset::Item_Potion_POTION_TYPE_IsValid(value));
  set_has_potion_type();
  potion_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Potion.potion_type)
}

// optional int32 increase_value = 4;
inline bool Item_Potion::has_increase_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Item_Potion::set_has_increase_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Item_Potion::clear_has_increase_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Item_Potion::clear_increase_value() {
  increase_value_ = 0;
  clear_has_increase_value();
}
inline ::google::protobuf::int32 Item_Potion::increase_value() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Potion.increase_value)
  return increase_value_;
}
inline void Item_Potion::set_increase_value(::google::protobuf::int32 value) {
  set_has_increase_value();
  increase_value_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Potion.increase_value)
}

// -------------------------------------------------------------------

// Item_Equipment

// optional .Adoter.Asset.ASSET_TYPE type_t = 1 [default = ITEM_TYPE_EQUIPMENT];
inline bool Item_Equipment::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_Equipment::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_Equipment::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_Equipment::clear_type_t() {
  type_t_ = 203;
  clear_has_type_t();
}
inline ::Adoter::Asset::ASSET_TYPE Item_Equipment::type_t() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Equipment.type_t)
  return static_cast< ::Adoter::Asset::ASSET_TYPE >(type_t_);
}
inline void Item_Equipment::set_type_t(::Adoter::Asset::ASSET_TYPE value) {
  assert(::Adoter::Asset::ASSET_TYPE_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Equipment.type_t)
}

// optional .Adoter.Asset.Item_CommonProp item_common_prop = 2;
inline bool Item_Equipment::has_item_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_Equipment::set_has_item_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_Equipment::clear_has_item_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_Equipment::clear_item_common_prop() {
  if (item_common_prop_ != NULL) item_common_prop_->::Adoter::Asset::Item_CommonProp::Clear();
  clear_has_item_common_prop();
}
inline const ::Adoter::Asset::Item_CommonProp& Item_Equipment::item_common_prop() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Equipment.item_common_prop)
  return item_common_prop_ != NULL ? *item_common_prop_ : *default_instance_->item_common_prop_;
}
inline ::Adoter::Asset::Item_CommonProp* Item_Equipment::mutable_item_common_prop() {
  set_has_item_common_prop();
  if (item_common_prop_ == NULL) item_common_prop_ = new ::Adoter::Asset::Item_CommonProp;
  // @@protoc_insertion_point(field_mutable:Adoter.Asset.Item_Equipment.item_common_prop)
  return item_common_prop_;
}
inline ::Adoter::Asset::Item_CommonProp* Item_Equipment::release_item_common_prop() {
  clear_has_item_common_prop();
  ::Adoter::Asset::Item_CommonProp* temp = item_common_prop_;
  item_common_prop_ = NULL;
  return temp;
}
inline void Item_Equipment::set_allocated_item_common_prop(::Adoter::Asset::Item_CommonProp* item_common_prop) {
  delete item_common_prop_;
  item_common_prop_ = item_common_prop;
  if (item_common_prop) {
    set_has_item_common_prop();
  } else {
    clear_has_item_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:Adoter.Asset.Item_Equipment.item_common_prop)
}

// optional .Adoter.Asset.Item_Equipment.EQUIP_TYPE equip_type = 3;
inline bool Item_Equipment::has_equip_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item_Equipment::set_has_equip_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item_Equipment::clear_has_equip_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item_Equipment::clear_equip_type() {
  equip_type_ = 1;
  clear_has_equip_type();
}
inline ::Adoter::Asset::Item_Equipment_EQUIP_TYPE Item_Equipment::equip_type() const {
  // @@protoc_insertion_point(field_get:Adoter.Asset.Item_Equipment.equip_type)
  return static_cast< ::Adoter::Asset::Item_Equipment_EQUIP_TYPE >(equip_type_);
}
inline void Item_Equipment::set_equip_type(::Adoter::Asset::Item_Equipment_EQUIP_TYPE value) {
  assert(::Adoter::Asset::Item_Equipment_EQUIP_TYPE_IsValid(value));
  set_has_equip_type();
  equip_type_ = value;
  // @@protoc_insertion_point(field_set:Adoter.Asset.Item_Equipment.equip_type)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Asset
}  // namespace Adoter

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE>() {
  return ::Adoter::Asset::CommonLimit_COMMON_LIMIT_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE>() {
  return ::Adoter::Asset::CommonLimit_COOL_DOWN_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::Harm_HARM_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::Harm_HARM_TYPE>() {
  return ::Adoter::Asset::Harm_HARM_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::LevelUpCurve_Consume_CONSUME_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::LevelUpCurve_Consume_CONSUME_TYPE>() {
  return ::Adoter::Asset::LevelUpCurve_Consume_CONSUME_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::Item_Potion_POTION_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::Item_Potion_POTION_TYPE>() {
  return ::Adoter::Asset::Item_Potion_POTION_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::Item_Equipment_EQUIP_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::Item_Equipment_EQUIP_TYPE>() {
  return ::Adoter::Asset::Item_Equipment_EQUIP_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::PROF_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::PROF_TYPE>() {
  return ::Adoter::Asset::PROF_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::INVENTORY_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::INVENTORY_TYPE>() {
  return ::Adoter::Asset::INVENTORY_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ENTITY_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ENTITY_TYPE>() {
  return ::Adoter::Asset::ENTITY_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::CAMP_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::CAMP_TYPE>() {
  return ::Adoter::Asset::CAMP_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::VERSION_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::VERSION_TYPE>() {
  return ::Adoter::Asset::VERSION_TYPE_descriptor();
}
template <> struct is_proto_enum< ::Adoter::Asset::ASSET_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Adoter::Asset::ASSET_TYPE>() {
  return ::Adoter::Asset::ASSET_TYPE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_P_5fAsset_2eproto__INCLUDED
