// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CommonConfig.proto

#ifndef PROTOBUF_CommonConfig_2eproto__INCLUDED
#define PROTOBUF_CommonConfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/protobuf/descriptor.pb.h"
// @@protoc_insertion_point(includes)

namespace real {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CommonConfig_2eproto();
void protobuf_AssignDesc_CommonConfig_2eproto();
void protobuf_ShutdownFile_CommonConfig_2eproto();

class Vector2;
class Vector3;
class CommonProp;
class CCommonProp;
class Plant;
class CommonLimit;
class CoolDown;
class Hoster;
class Harm;
class Skill;
class LevelUpCurve;
class LevelUpCurve_Consume;
class Scene;
class Item_CommonProp;
class Item_Item;
class Item_Potion;
class Item_Equipment;

enum CommonLimit_CommonLimitType {
  CommonLimit_CommonLimitType_COMMON_LIMIT_TYPE_PLANT = 1
};
bool CommonLimit_CommonLimitType_IsValid(int value);
const CommonLimit_CommonLimitType CommonLimit_CommonLimitType_CommonLimitType_MIN = CommonLimit_CommonLimitType_COMMON_LIMIT_TYPE_PLANT;
const CommonLimit_CommonLimitType CommonLimit_CommonLimitType_CommonLimitType_MAX = CommonLimit_CommonLimitType_COMMON_LIMIT_TYPE_PLANT;
const int CommonLimit_CommonLimitType_CommonLimitType_ARRAYSIZE = CommonLimit_CommonLimitType_CommonLimitType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonLimit_CommonLimitType_descriptor();
inline const ::std::string& CommonLimit_CommonLimitType_Name(CommonLimit_CommonLimitType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonLimit_CommonLimitType_descriptor(), value);
}
inline bool CommonLimit_CommonLimitType_Parse(
    const ::std::string& name, CommonLimit_CommonLimitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonLimit_CommonLimitType>(
    CommonLimit_CommonLimitType_descriptor(), name, value);
}
enum CommonLimit_CoolDownType {
  CommonLimit_CoolDownType_COOL_DOWN_TYPE_DAY = 1,
  CommonLimit_CoolDownType_COOL_DOWN_TYPE_WEEK = 2,
  CommonLimit_CoolDownType_COOL_DOWN_TYPE_MONTH = 3,
  CommonLimit_CoolDownType_COOL_DOWN_TYPE_YEAR = 4,
  CommonLimit_CoolDownType_COOL_DOWN_TYPE_NEVER = 5
};
bool CommonLimit_CoolDownType_IsValid(int value);
const CommonLimit_CoolDownType CommonLimit_CoolDownType_CoolDownType_MIN = CommonLimit_CoolDownType_COOL_DOWN_TYPE_DAY;
const CommonLimit_CoolDownType CommonLimit_CoolDownType_CoolDownType_MAX = CommonLimit_CoolDownType_COOL_DOWN_TYPE_NEVER;
const int CommonLimit_CoolDownType_CoolDownType_ARRAYSIZE = CommonLimit_CoolDownType_CoolDownType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommonLimit_CoolDownType_descriptor();
inline const ::std::string& CommonLimit_CoolDownType_Name(CommonLimit_CoolDownType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommonLimit_CoolDownType_descriptor(), value);
}
inline bool CommonLimit_CoolDownType_Parse(
    const ::std::string& name, CommonLimit_CoolDownType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommonLimit_CoolDownType>(
    CommonLimit_CoolDownType_descriptor(), name, value);
}
enum Harm_HarmType {
  Harm_HarmType_HARM_TYPE_HP = 1,
  Harm_HarmType_HARM_TYPE_MP = 2,
  Harm_HarmType_HARM_TYPE_SPEED = 3
};
bool Harm_HarmType_IsValid(int value);
const Harm_HarmType Harm_HarmType_HarmType_MIN = Harm_HarmType_HARM_TYPE_HP;
const Harm_HarmType Harm_HarmType_HarmType_MAX = Harm_HarmType_HARM_TYPE_SPEED;
const int Harm_HarmType_HarmType_ARRAYSIZE = Harm_HarmType_HarmType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Harm_HarmType_descriptor();
inline const ::std::string& Harm_HarmType_Name(Harm_HarmType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Harm_HarmType_descriptor(), value);
}
inline bool Harm_HarmType_Parse(
    const ::std::string& name, Harm_HarmType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Harm_HarmType>(
    Harm_HarmType_descriptor(), name, value);
}
enum LevelUpCurve_Consume_CosumeType {
  LevelUpCurve_Consume_CosumeType_CONSUME_TYPE_EXPERIENCE = 1,
  LevelUpCurve_Consume_CosumeType_CONSUME_TYPE_DIOMAND = 2,
  LevelUpCurve_Consume_CosumeType_CONSUME_TYPE_TIME = 3
};
bool LevelUpCurve_Consume_CosumeType_IsValid(int value);
const LevelUpCurve_Consume_CosumeType LevelUpCurve_Consume_CosumeType_CosumeType_MIN = LevelUpCurve_Consume_CosumeType_CONSUME_TYPE_EXPERIENCE;
const LevelUpCurve_Consume_CosumeType LevelUpCurve_Consume_CosumeType_CosumeType_MAX = LevelUpCurve_Consume_CosumeType_CONSUME_TYPE_TIME;
const int LevelUpCurve_Consume_CosumeType_CosumeType_ARRAYSIZE = LevelUpCurve_Consume_CosumeType_CosumeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LevelUpCurve_Consume_CosumeType_descriptor();
inline const ::std::string& LevelUpCurve_Consume_CosumeType_Name(LevelUpCurve_Consume_CosumeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LevelUpCurve_Consume_CosumeType_descriptor(), value);
}
inline bool LevelUpCurve_Consume_CosumeType_Parse(
    const ::std::string& name, LevelUpCurve_Consume_CosumeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LevelUpCurve_Consume_CosumeType>(
    LevelUpCurve_Consume_CosumeType_descriptor(), name, value);
}
enum Item_Potion_PotionType {
  Item_Potion_PotionType_POTION_TYPE_HEMO = 1,
  Item_Potion_PotionType_POTION_TYPE_MAGIC = 2,
  Item_Potion_PotionType_POTION_TYPE_PHYSICAL_STRENGTH = 3
};
bool Item_Potion_PotionType_IsValid(int value);
const Item_Potion_PotionType Item_Potion_PotionType_PotionType_MIN = Item_Potion_PotionType_POTION_TYPE_HEMO;
const Item_Potion_PotionType Item_Potion_PotionType_PotionType_MAX = Item_Potion_PotionType_POTION_TYPE_PHYSICAL_STRENGTH;
const int Item_Potion_PotionType_PotionType_ARRAYSIZE = Item_Potion_PotionType_PotionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Item_Potion_PotionType_descriptor();
inline const ::std::string& Item_Potion_PotionType_Name(Item_Potion_PotionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Item_Potion_PotionType_descriptor(), value);
}
inline bool Item_Potion_PotionType_Parse(
    const ::std::string& name, Item_Potion_PotionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Item_Potion_PotionType>(
    Item_Potion_PotionType_descriptor(), name, value);
}
enum Item_Equipment_EuipType {
  Item_Equipment_EuipType_EQUIP_TYPE_HELMET = 1
};
bool Item_Equipment_EuipType_IsValid(int value);
const Item_Equipment_EuipType Item_Equipment_EuipType_EuipType_MIN = Item_Equipment_EuipType_EQUIP_TYPE_HELMET;
const Item_Equipment_EuipType Item_Equipment_EuipType_EuipType_MAX = Item_Equipment_EuipType_EQUIP_TYPE_HELMET;
const int Item_Equipment_EuipType_EuipType_ARRAYSIZE = Item_Equipment_EuipType_EuipType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Item_Equipment_EuipType_descriptor();
inline const ::std::string& Item_Equipment_EuipType_Name(Item_Equipment_EuipType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Item_Equipment_EuipType_descriptor(), value);
}
inline bool Item_Equipment_EuipType_Parse(
    const ::std::string& name, Item_Equipment_EuipType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Item_Equipment_EuipType>(
    Item_Equipment_EuipType_descriptor(), name, value);
}
enum ProfType {
  PROFTYPE_FARMER = 1,
  PROFTYPE_FARMER_HOSTER = 2,
  PROFTYPE_FARMER_AND_HOSTER = 3,
  PROFTYPE_COWBOY = 4,
  PROFTYPE_BOUNTY_HUNTER = 16
};
bool ProfType_IsValid(int value);
const ProfType ProfType_MIN = PROFTYPE_FARMER;
const ProfType ProfType_MAX = PROFTYPE_BOUNTY_HUNTER;
const int ProfType_ARRAYSIZE = ProfType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProfType_descriptor();
inline const ::std::string& ProfType_Name(ProfType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProfType_descriptor(), value);
}
inline bool ProfType_Parse(
    const ::std::string& name, ProfType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProfType>(
    ProfType_descriptor(), name, value);
}
enum InventoryType {
  INVENTORY_TYPE_BACKPACKAGE = 1,
  INVENTORY_TYPE_EQUIPMENT = 2,
  INVENTORY_TYPE_FASHION = 3,
  INVENTORY_TYPE_COUNT = 4
};
bool InventoryType_IsValid(int value);
const InventoryType InventoryType_MIN = INVENTORY_TYPE_BACKPACKAGE;
const InventoryType InventoryType_MAX = INVENTORY_TYPE_COUNT;
const int InventoryType_ARRAYSIZE = InventoryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InventoryType_descriptor();
inline const ::std::string& InventoryType_Name(InventoryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InventoryType_descriptor(), value);
}
inline bool InventoryType_Parse(
    const ::std::string& name, InventoryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InventoryType>(
    InventoryType_descriptor(), name, value);
}
enum EntityType {
  ENTITY_TYPE_NIL = 1,
  ENTITY_TYPE_PLAYER = 2,
  ENTITY_TYPE_HOST = 3,
  ENTITY_TYPE_NPC = 4,
  ENTITY_TYPE_BUILDING = 5,
  ENTITY_TYPE_SEA = 6,
  ENTITY_TYPE_AIR = 7,
  ENTITY_TYPE_LAND = 8
};
bool EntityType_IsValid(int value);
const EntityType EntityType_MIN = ENTITY_TYPE_NIL;
const EntityType EntityType_MAX = ENTITY_TYPE_LAND;
const int EntityType_ARRAYSIZE = EntityType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntityType_descriptor();
inline const ::std::string& EntityType_Name(EntityType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntityType_descriptor(), value);
}
inline bool EntityType_Parse(
    const ::std::string& name, EntityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityType>(
    EntityType_descriptor(), name, value);
}
enum CampType {
  CAMP_TYPE_HUMON = 1
};
bool CampType_IsValid(int value);
const CampType CampType_MIN = CAMP_TYPE_HUMON;
const CampType CampType_MAX = CAMP_TYPE_HUMON;
const int CampType_ARRAYSIZE = CampType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CampType_descriptor();
inline const ::std::string& CampType_Name(CampType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CampType_descriptor(), value);
}
inline bool CampType_Parse(
    const ::std::string& name, CampType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CampType>(
    CampType_descriptor(), name, value);
}
enum Version {
  GLOBAL = 1,
  MAINLAND = 2,
  TAIWAN = 3
};
bool Version_IsValid(int value);
const Version Version_MIN = GLOBAL;
const Version Version_MAX = TAIWAN;
const int Version_ARRAYSIZE = Version_MAX + 1;

const ::google::protobuf::EnumDescriptor* Version_descriptor();
inline const ::std::string& Version_Name(Version value) {
  return ::google::protobuf::internal::NameOfEnum(
    Version_descriptor(), value);
}
inline bool Version_Parse(
    const ::std::string& name, Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Version>(
    Version_descriptor(), name, value);
}
enum ConfigType {
  CONFIG_TYPE_BEGIN = 1,
  CONFIG_TYPE_PLANT = 2,
  CONFIG_TYPE_COMMON_LIMIT = 3,
  CONFIG_TYPE_COMMON_REWARD = 4,
  CONFIG_TYPE_COOL_DOWN = 5,
  CONFIG_TYPE_HOSTER = 6,
  CONFIG_TYPE_SKILL = 7,
  CONFIG_TYPE_LEVEL_UP = 8,
  CONFIG_TYPE_SCENE = 9,
  CONFIG_TYPE_COUNT = 200,
  ITEM_TYPE_BEGIN = 201,
  ITEM_TYPE_POTION = 202,
  ITEM_TYPE_EQUIPMENT = 203,
  ITEM_TYPE_GUN = 204
};
bool ConfigType_IsValid(int value);
const ConfigType ConfigType_MIN = CONFIG_TYPE_BEGIN;
const ConfigType ConfigType_MAX = ITEM_TYPE_GUN;
const int ConfigType_ARRAYSIZE = ConfigType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConfigType_descriptor();
inline const ::std::string& ConfigType_Name(ConfigType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConfigType_descriptor(), value);
}
inline bool ConfigType_Parse(
    const ::std::string& name, ConfigType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConfigType>(
    ConfigType_descriptor(), name, value);
}
// ===================================================================

class Vector2 : public ::google::protobuf::Message {
 public:
  Vector2();
  virtual ~Vector2();

  Vector2(const Vector2& from);

  inline Vector2& operator=(const Vector2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector2& default_instance();

  void Swap(Vector2* other);

  // implements Message ----------------------------------------------

  Vector2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector2& from);
  void MergeFrom(const Vector2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float z = 2;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 2;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:real.Vector2)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float z_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static Vector2* default_instance_;
};
// -------------------------------------------------------------------

class Vector3 : public ::google::protobuf::Message {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  void Swap(Vector3* other);

  // implements Message ----------------------------------------------

  Vector3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:real.Vector3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static Vector3* default_instance_;
};
// -------------------------------------------------------------------

class CommonProp : public ::google::protobuf::Message {
 public:
  CommonProp();
  virtual ~CommonProp();

  CommonProp(const CommonProp& from);

  inline CommonProp& operator=(const CommonProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonProp& default_instance();

  void Swap(CommonProp* other);

  // implements Message ----------------------------------------------

  CommonProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonProp& from);
  void MergeFrom(const CommonProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional .real.EntityType entity_type = 2;
  inline bool has_entity_type() const;
  inline void clear_entity_type();
  static const int kEntityTypeFieldNumber = 2;
  inline ::real::EntityType entity_type() const;
  inline void set_entity_type(::real::EntityType value);

  // optional bytes name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 radius = 4;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 4;
  inline ::google::protobuf::int32 radius() const;
  inline void set_radius(::google::protobuf::int32 value);

  // optional int32 height = 5;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 5;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 level = 6;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 6;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 gender = 7;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 7;
  inline ::google::protobuf::int32 gender() const;
  inline void set_gender(::google::protobuf::int32 value);

  // optional int32 profession = 8;
  inline bool has_profession() const;
  inline void clear_profession();
  static const int kProfessionFieldNumber = 8;
  inline ::google::protobuf::int32 profession() const;
  inline void set_profession(::google::protobuf::int32 value);

  // optional int32 speed = 9;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 9;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // optional int32 hp = 10;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 10;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // optional int32 mp = 11;
  inline bool has_mp() const;
  inline void clear_mp();
  static const int kMpFieldNumber = 11;
  inline ::google::protobuf::int32 mp() const;
  inline void set_mp(::google::protobuf::int32 value);

  // optional int32 orientation = 12;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 12;
  inline ::google::protobuf::int32 orientation() const;
  inline void set_orientation(::google::protobuf::int32 value);

  // optional int32 scene_id = 13;
  inline bool has_scene_id() const;
  inline void clear_scene_id();
  static const int kSceneIdFieldNumber = 13;
  inline ::google::protobuf::int32 scene_id() const;
  inline void set_scene_id(::google::protobuf::int32 value);

  // optional .real.Vector3 position = 14;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 14;
  inline const ::real::Vector3& position() const;
  inline ::real::Vector3* mutable_position();
  inline ::real::Vector3* release_position();
  inline void set_allocated_position(::real::Vector3* position);

  // optional float visibility_range = 15 [default = 90];
  inline bool has_visibility_range() const;
  inline void clear_visibility_range();
  static const int kVisibilityRangeFieldNumber = 15;
  inline float visibility_range() const;
  inline void set_visibility_range(float value);

  // optional .real.CampType camp_type = 16;
  inline bool has_camp_type() const;
  inline void clear_camp_type();
  static const int kCampTypeFieldNumber = 16;
  inline ::real::CampType camp_type() const;
  inline void set_camp_type(::real::CampType value);

  // repeated int32 skills = 17;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 17;
  inline ::google::protobuf::int32 skills(int index) const;
  inline void set_skills(int index, ::google::protobuf::int32 value);
  inline void add_skills(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      skills() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_skills();

  // optional int32 level_up_id = 18;
  inline bool has_level_up_id() const;
  inline void clear_level_up_id();
  static const int kLevelUpIdFieldNumber = 18;
  inline ::google::protobuf::int32 level_up_id() const;
  inline void set_level_up_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:real.CommonProp)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_entity_type();
  inline void clear_has_entity_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_profession();
  inline void clear_has_profession();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_mp();
  inline void clear_has_mp();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_scene_id();
  inline void clear_has_scene_id();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_visibility_range();
  inline void clear_has_visibility_range();
  inline void set_has_camp_type();
  inline void clear_has_camp_type();
  inline void set_has_level_up_id();
  inline void clear_has_level_up_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 id_;
  ::std::string* name_;
  int entity_type_;
  ::google::protobuf::int32 radius_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 gender_;
  ::google::protobuf::int32 profession_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 mp_;
  ::google::protobuf::int32 orientation_;
  ::real::Vector3* position_;
  ::google::protobuf::int32 scene_id_;
  float visibility_range_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > skills_;
  int camp_type_;
  ::google::protobuf::int32 level_up_id_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static CommonProp* default_instance_;
};
// -------------------------------------------------------------------

class CCommonProp : public ::google::protobuf::Message {
 public:
  CCommonProp();
  virtual ~CCommonProp();

  CCommonProp(const CCommonProp& from);

  inline CCommonProp& operator=(const CCommonProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CCommonProp& default_instance();

  void Swap(CCommonProp* other);

  // implements Message ----------------------------------------------

  CCommonProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CCommonProp& from);
  void MergeFrom(const CCommonProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required .real.Version version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::real::Version version() const;
  inline void set_version(::real::Version value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:real.CCommonProp)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  int version_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static CCommonProp* default_instance_;
};
// -------------------------------------------------------------------

class Plant : public ::google::protobuf::Message {
 public:
  Plant();
  virtual ~Plant();

  Plant(const Plant& from);

  inline Plant& operator=(const Plant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Plant& default_instance();

  void Swap(Plant* other);

  // implements Message ----------------------------------------------

  Plant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Plant& from);
  void MergeFrom(const Plant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_PLANT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::real::ConfigType type_t() const;
  inline void set_type_t(::real::ConfigType value);

  // optional .real.CCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::real::CCommonProp& common_prop() const;
  inline ::real::CCommonProp* mutable_common_prop();
  inline ::real::CCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::real::CCommonProp* common_prop);

  // @@protoc_insertion_point(class_scope:real.Plant)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::real::CCommonProp* common_prop_;
  int type_t_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static Plant* default_instance_;
};
// -------------------------------------------------------------------

class CommonLimit : public ::google::protobuf::Message {
 public:
  CommonLimit();
  virtual ~CommonLimit();

  CommonLimit(const CommonLimit& from);

  inline CommonLimit& operator=(const CommonLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonLimit& default_instance();

  void Swap(CommonLimit* other);

  // implements Message ----------------------------------------------

  CommonLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonLimit& from);
  void MergeFrom(const CommonLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CommonLimit_CommonLimitType CommonLimitType;
  static const CommonLimitType COMMON_LIMIT_TYPE_PLANT = CommonLimit_CommonLimitType_COMMON_LIMIT_TYPE_PLANT;
  static inline bool CommonLimitType_IsValid(int value) {
    return CommonLimit_CommonLimitType_IsValid(value);
  }
  static const CommonLimitType CommonLimitType_MIN =
    CommonLimit_CommonLimitType_CommonLimitType_MIN;
  static const CommonLimitType CommonLimitType_MAX =
    CommonLimit_CommonLimitType_CommonLimitType_MAX;
  static const int CommonLimitType_ARRAYSIZE =
    CommonLimit_CommonLimitType_CommonLimitType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommonLimitType_descriptor() {
    return CommonLimit_CommonLimitType_descriptor();
  }
  static inline const ::std::string& CommonLimitType_Name(CommonLimitType value) {
    return CommonLimit_CommonLimitType_Name(value);
  }
  static inline bool CommonLimitType_Parse(const ::std::string& name,
      CommonLimitType* value) {
    return CommonLimit_CommonLimitType_Parse(name, value);
  }

  typedef CommonLimit_CoolDownType CoolDownType;
  static const CoolDownType COOL_DOWN_TYPE_DAY = CommonLimit_CoolDownType_COOL_DOWN_TYPE_DAY;
  static const CoolDownType COOL_DOWN_TYPE_WEEK = CommonLimit_CoolDownType_COOL_DOWN_TYPE_WEEK;
  static const CoolDownType COOL_DOWN_TYPE_MONTH = CommonLimit_CoolDownType_COOL_DOWN_TYPE_MONTH;
  static const CoolDownType COOL_DOWN_TYPE_YEAR = CommonLimit_CoolDownType_COOL_DOWN_TYPE_YEAR;
  static const CoolDownType COOL_DOWN_TYPE_NEVER = CommonLimit_CoolDownType_COOL_DOWN_TYPE_NEVER;
  static inline bool CoolDownType_IsValid(int value) {
    return CommonLimit_CoolDownType_IsValid(value);
  }
  static const CoolDownType CoolDownType_MIN =
    CommonLimit_CoolDownType_CoolDownType_MIN;
  static const CoolDownType CoolDownType_MAX =
    CommonLimit_CoolDownType_CoolDownType_MAX;
  static const int CoolDownType_ARRAYSIZE =
    CommonLimit_CoolDownType_CoolDownType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CoolDownType_descriptor() {
    return CommonLimit_CoolDownType_descriptor();
  }
  static inline const ::std::string& CoolDownType_Name(CoolDownType value) {
    return CommonLimit_CoolDownType_Name(value);
  }
  static inline bool CoolDownType_Parse(const ::std::string& name,
      CoolDownType* value) {
    return CommonLimit_CoolDownType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_COMMON_LIMIT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::real::ConfigType type_t() const;
  inline void set_type_t(::real::ConfigType value);

  // optional .real.CCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::real::CCommonProp& common_prop() const;
  inline ::real::CCommonProp* mutable_common_prop();
  inline ::real::CCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::real::CCommonProp* common_prop);

  // optional .real.CommonLimit.CommonLimitType limit_type = 3;
  inline bool has_limit_type() const;
  inline void clear_limit_type();
  static const int kLimitTypeFieldNumber = 3;
  inline ::real::CommonLimit_CommonLimitType limit_type() const;
  inline void set_limit_type(::real::CommonLimit_CommonLimitType value);

  // optional .real.CommonLimit.CoolDownType cool_down_type = 4;
  inline bool has_cool_down_type() const;
  inline void clear_cool_down_type();
  static const int kCoolDownTypeFieldNumber = 4;
  inline ::real::CommonLimit_CoolDownType cool_down_type() const;
  inline void set_cool_down_type(::real::CommonLimit_CoolDownType value);

  // @@protoc_insertion_point(class_scope:real.CommonLimit)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_limit_type();
  inline void clear_has_limit_type();
  inline void set_has_cool_down_type();
  inline void clear_has_cool_down_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::real::CCommonProp* common_prop_;
  int type_t_;
  int limit_type_;
  int cool_down_type_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static CommonLimit* default_instance_;
};
// -------------------------------------------------------------------

class CoolDown : public ::google::protobuf::Message {
 public:
  CoolDown();
  virtual ~CoolDown();

  CoolDown(const CoolDown& from);

  inline CoolDown& operator=(const CoolDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoolDown& default_instance();

  void Swap(CoolDown* other);

  // implements Message ----------------------------------------------

  CoolDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoolDown& from);
  void MergeFrom(const CoolDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_COOL_DOWN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::real::ConfigType type_t() const;
  inline void set_type_t(::real::ConfigType value);

  // optional .real.CCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::real::CCommonProp& common_prop() const;
  inline ::real::CCommonProp* mutable_common_prop();
  inline ::real::CCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::real::CCommonProp* common_prop);

  // optional int32 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:real.CoolDown)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::real::CCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 time_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static CoolDown* default_instance_;
};
// -------------------------------------------------------------------

class Hoster : public ::google::protobuf::Message {
 public:
  Hoster();
  virtual ~Hoster();

  Hoster(const Hoster& from);

  inline Hoster& operator=(const Hoster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hoster& default_instance();

  void Swap(Hoster* other);

  // implements Message ----------------------------------------------

  Hoster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hoster& from);
  void MergeFrom(const Hoster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_HOSTER];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::real::ConfigType type_t() const;
  inline void set_type_t(::real::ConfigType value);

  // optional .real.CCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::real::CCommonProp& common_prop() const;
  inline ::real::CCommonProp* mutable_common_prop();
  inline ::real::CCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::real::CCommonProp* common_prop);

  // optional .real.CommonProp human_prop = 3;
  inline bool has_human_prop() const;
  inline void clear_human_prop();
  static const int kHumanPropFieldNumber = 3;
  inline const ::real::CommonProp& human_prop() const;
  inline ::real::CommonProp* mutable_human_prop();
  inline ::real::CommonProp* release_human_prop();
  inline void set_allocated_human_prop(::real::CommonProp* human_prop);

  // optional string behaviac_tree_path = 4;
  inline bool has_behaviac_tree_path() const;
  inline void clear_behaviac_tree_path();
  static const int kBehaviacTreePathFieldNumber = 4;
  inline const ::std::string& behaviac_tree_path() const;
  inline void set_behaviac_tree_path(const ::std::string& value);
  inline void set_behaviac_tree_path(const char* value);
  inline void set_behaviac_tree_path(const char* value, size_t size);
  inline ::std::string* mutable_behaviac_tree_path();
  inline ::std::string* release_behaviac_tree_path();
  inline void set_allocated_behaviac_tree_path(::std::string* behaviac_tree_path);

  // optional int32 build_time = 5;
  inline bool has_build_time() const;
  inline void clear_build_time();
  static const int kBuildTimeFieldNumber = 5;
  inline ::google::protobuf::int32 build_time() const;
  inline void set_build_time(::google::protobuf::int32 value);

  // optional int32 attack_speed = 6;
  inline bool has_attack_speed() const;
  inline void clear_attack_speed();
  static const int kAttackSpeedFieldNumber = 6;
  inline ::google::protobuf::int32 attack_speed() const;
  inline void set_attack_speed(::google::protobuf::int32 value);

  // optional int32 produce_entity_id = 7;
  inline bool has_produce_entity_id() const;
  inline void clear_produce_entity_id();
  static const int kProduceEntityIdFieldNumber = 7;
  inline ::google::protobuf::int32 produce_entity_id() const;
  inline void set_produce_entity_id(::google::protobuf::int32 value);

  // optional int32 produce_entity_speed = 8;
  inline bool has_produce_entity_speed() const;
  inline void clear_produce_entity_speed();
  static const int kProduceEntitySpeedFieldNumber = 8;
  inline ::google::protobuf::int32 produce_entity_speed() const;
  inline void set_produce_entity_speed(::google::protobuf::int32 value);

  // optional int32 produce_entity_count = 9;
  inline bool has_produce_entity_count() const;
  inline void clear_produce_entity_count();
  static const int kProduceEntityCountFieldNumber = 9;
  inline ::google::protobuf::int32 produce_entity_count() const;
  inline void set_produce_entity_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:real.Hoster)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_human_prop();
  inline void clear_has_human_prop();
  inline void set_has_behaviac_tree_path();
  inline void clear_has_behaviac_tree_path();
  inline void set_has_build_time();
  inline void clear_has_build_time();
  inline void set_has_attack_speed();
  inline void clear_has_attack_speed();
  inline void set_has_produce_entity_id();
  inline void clear_has_produce_entity_id();
  inline void set_has_produce_entity_speed();
  inline void clear_has_produce_entity_speed();
  inline void set_has_produce_entity_count();
  inline void clear_has_produce_entity_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::real::CCommonProp* common_prop_;
  ::real::CommonProp* human_prop_;
  int type_t_;
  ::google::protobuf::int32 build_time_;
  ::std::string* behaviac_tree_path_;
  ::google::protobuf::int32 attack_speed_;
  ::google::protobuf::int32 produce_entity_id_;
  ::google::protobuf::int32 produce_entity_speed_;
  ::google::protobuf::int32 produce_entity_count_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static Hoster* default_instance_;
};
// -------------------------------------------------------------------

class Harm : public ::google::protobuf::Message {
 public:
  Harm();
  virtual ~Harm();

  Harm(const Harm& from);

  inline Harm& operator=(const Harm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Harm& default_instance();

  void Swap(Harm* other);

  // implements Message ----------------------------------------------

  Harm* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Harm& from);
  void MergeFrom(const Harm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Harm_HarmType HarmType;
  static const HarmType HARM_TYPE_HP = Harm_HarmType_HARM_TYPE_HP;
  static const HarmType HARM_TYPE_MP = Harm_HarmType_HARM_TYPE_MP;
  static const HarmType HARM_TYPE_SPEED = Harm_HarmType_HARM_TYPE_SPEED;
  static inline bool HarmType_IsValid(int value) {
    return Harm_HarmType_IsValid(value);
  }
  static const HarmType HarmType_MIN =
    Harm_HarmType_HarmType_MIN;
  static const HarmType HarmType_MAX =
    Harm_HarmType_HarmType_MAX;
  static const int HarmType_ARRAYSIZE =
    Harm_HarmType_HarmType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HarmType_descriptor() {
    return Harm_HarmType_descriptor();
  }
  static inline const ::std::string& HarmType_Name(HarmType value) {
    return Harm_HarmType_Name(value);
  }
  static inline bool HarmType_Parse(const ::std::string& name,
      HarmType* value) {
    return Harm_HarmType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .real.Harm.HarmType harm_type = 1;
  inline bool has_harm_type() const;
  inline void clear_harm_type();
  static const int kHarmTypeFieldNumber = 1;
  inline ::real::Harm_HarmType harm_type() const;
  inline void set_harm_type(::real::Harm_HarmType value);

  // optional int32 harm_total = 2;
  inline bool has_harm_total() const;
  inline void clear_harm_total();
  static const int kHarmTotalFieldNumber = 2;
  inline ::google::protobuf::int32 harm_total() const;
  inline void set_harm_total(::google::protobuf::int32 value);

  // optional int32 last_time = 3;
  inline bool has_last_time() const;
  inline void clear_last_time();
  static const int kLastTimeFieldNumber = 3;
  inline ::google::protobuf::int32 last_time() const;
  inline void set_last_time(::google::protobuf::int32 value);

  // optional int32 harm_per_second = 4;
  inline bool has_harm_per_second() const;
  inline void clear_harm_per_second();
  static const int kHarmPerSecondFieldNumber = 4;
  inline ::google::protobuf::int32 harm_per_second() const;
  inline void set_harm_per_second(::google::protobuf::int32 value);

  // optional int32 harm_range = 5;
  inline bool has_harm_range() const;
  inline void clear_harm_range();
  static const int kHarmRangeFieldNumber = 5;
  inline ::google::protobuf::int32 harm_range() const;
  inline void set_harm_range(::google::protobuf::int32 value);

  // optional .real.EntityType harm_target = 6;
  inline bool has_harm_target() const;
  inline void clear_harm_target();
  static const int kHarmTargetFieldNumber = 6;
  inline ::real::EntityType harm_target() const;
  inline void set_harm_target(::real::EntityType value);

  // @@protoc_insertion_point(class_scope:real.Harm)
 private:
  inline void set_has_harm_type();
  inline void clear_has_harm_type();
  inline void set_has_harm_total();
  inline void clear_has_harm_total();
  inline void set_has_last_time();
  inline void clear_has_last_time();
  inline void set_has_harm_per_second();
  inline void clear_has_harm_per_second();
  inline void set_has_harm_range();
  inline void clear_has_harm_range();
  inline void set_has_harm_target();
  inline void clear_has_harm_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int harm_type_;
  ::google::protobuf::int32 harm_total_;
  ::google::protobuf::int32 last_time_;
  ::google::protobuf::int32 harm_per_second_;
  ::google::protobuf::int32 harm_range_;
  int harm_target_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static Harm* default_instance_;
};
// -------------------------------------------------------------------

class Skill : public ::google::protobuf::Message {
 public:
  Skill();
  virtual ~Skill();

  Skill(const Skill& from);

  inline Skill& operator=(const Skill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Skill& default_instance();

  void Swap(Skill* other);

  // implements Message ----------------------------------------------

  Skill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Skill& from);
  void MergeFrom(const Skill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_SKILL];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::real::ConfigType type_t() const;
  inline void set_type_t(::real::ConfigType value);

  // optional .real.CCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::real::CCommonProp& common_prop() const;
  inline ::real::CCommonProp* mutable_common_prop();
  inline ::real::CCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::real::CCommonProp* common_prop);

  // optional int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional string behaviac_tree_path = 4;
  inline bool has_behaviac_tree_path() const;
  inline void clear_behaviac_tree_path();
  static const int kBehaviacTreePathFieldNumber = 4;
  inline const ::std::string& behaviac_tree_path() const;
  inline void set_behaviac_tree_path(const ::std::string& value);
  inline void set_behaviac_tree_path(const char* value);
  inline void set_behaviac_tree_path(const char* value, size_t size);
  inline ::std::string* mutable_behaviac_tree_path();
  inline ::std::string* release_behaviac_tree_path();
  inline void set_allocated_behaviac_tree_path(::std::string* behaviac_tree_path);

  // optional int32 cool_down_id = 5;
  inline bool has_cool_down_id() const;
  inline void clear_cool_down_id();
  static const int kCoolDownIdFieldNumber = 5;
  inline ::google::protobuf::int32 cool_down_id() const;
  inline void set_cool_down_id(::google::protobuf::int32 value);

  // optional int32 defense = 6;
  inline bool has_defense() const;
  inline void clear_defense();
  static const int kDefenseFieldNumber = 6;
  inline ::google::protobuf::int32 defense() const;
  inline void set_defense(::google::protobuf::int32 value);

  // optional .real.Harm harm = 7;
  inline bool has_harm() const;
  inline void clear_harm();
  static const int kHarmFieldNumber = 7;
  inline const ::real::Harm& harm() const;
  inline ::real::Harm* mutable_harm();
  inline ::real::Harm* release_harm();
  inline void set_allocated_harm(::real::Harm* harm);

  // optional int32 summon_entity_id = 8;
  inline bool has_summon_entity_id() const;
  inline void clear_summon_entity_id();
  static const int kSummonEntityIdFieldNumber = 8;
  inline ::google::protobuf::int32 summon_entity_id() const;
  inline void set_summon_entity_id(::google::protobuf::int32 value);

  // optional int32 death_harm_total = 9;
  inline bool has_death_harm_total() const;
  inline void clear_death_harm_total();
  static const int kDeathHarmTotalFieldNumber = 9;
  inline ::google::protobuf::int32 death_harm_total() const;
  inline void set_death_harm_total(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:real.Skill)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_behaviac_tree_path();
  inline void clear_has_behaviac_tree_path();
  inline void set_has_cool_down_id();
  inline void clear_has_cool_down_id();
  inline void set_has_defense();
  inline void clear_has_defense();
  inline void set_has_harm();
  inline void clear_has_harm();
  inline void set_has_summon_entity_id();
  inline void clear_has_summon_entity_id();
  inline void set_has_death_harm_total();
  inline void clear_has_death_harm_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::real::CCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 level_;
  ::std::string* behaviac_tree_path_;
  ::google::protobuf::int32 cool_down_id_;
  ::google::protobuf::int32 defense_;
  ::real::Harm* harm_;
  ::google::protobuf::int32 summon_entity_id_;
  ::google::protobuf::int32 death_harm_total_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static Skill* default_instance_;
};
// -------------------------------------------------------------------

class LevelUpCurve_Consume : public ::google::protobuf::Message {
 public:
  LevelUpCurve_Consume();
  virtual ~LevelUpCurve_Consume();

  LevelUpCurve_Consume(const LevelUpCurve_Consume& from);

  inline LevelUpCurve_Consume& operator=(const LevelUpCurve_Consume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LevelUpCurve_Consume& default_instance();

  void Swap(LevelUpCurve_Consume* other);

  // implements Message ----------------------------------------------

  LevelUpCurve_Consume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LevelUpCurve_Consume& from);
  void MergeFrom(const LevelUpCurve_Consume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LevelUpCurve_Consume_CosumeType CosumeType;
  static const CosumeType CONSUME_TYPE_EXPERIENCE = LevelUpCurve_Consume_CosumeType_CONSUME_TYPE_EXPERIENCE;
  static const CosumeType CONSUME_TYPE_DIOMAND = LevelUpCurve_Consume_CosumeType_CONSUME_TYPE_DIOMAND;
  static const CosumeType CONSUME_TYPE_TIME = LevelUpCurve_Consume_CosumeType_CONSUME_TYPE_TIME;
  static inline bool CosumeType_IsValid(int value) {
    return LevelUpCurve_Consume_CosumeType_IsValid(value);
  }
  static const CosumeType CosumeType_MIN =
    LevelUpCurve_Consume_CosumeType_CosumeType_MIN;
  static const CosumeType CosumeType_MAX =
    LevelUpCurve_Consume_CosumeType_CosumeType_MAX;
  static const int CosumeType_ARRAYSIZE =
    LevelUpCurve_Consume_CosumeType_CosumeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CosumeType_descriptor() {
    return LevelUpCurve_Consume_CosumeType_descriptor();
  }
  static inline const ::std::string& CosumeType_Name(CosumeType value) {
    return LevelUpCurve_Consume_CosumeType_Name(value);
  }
  static inline bool CosumeType_Parse(const ::std::string& name,
      CosumeType* value) {
    return LevelUpCurve_Consume_CosumeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 level_up = 1;
  inline bool has_level_up() const;
  inline void clear_level_up();
  static const int kLevelUpFieldNumber = 1;
  inline ::google::protobuf::int32 level_up() const;
  inline void set_level_up(::google::protobuf::int32 value);

  // optional .real.LevelUpCurve.Consume.CosumeType consume_type = 2;
  inline bool has_consume_type() const;
  inline void clear_consume_type();
  static const int kConsumeTypeFieldNumber = 2;
  inline ::real::LevelUpCurve_Consume_CosumeType consume_type() const;
  inline void set_consume_type(::real::LevelUpCurve_Consume_CosumeType value);

  // optional int32 consume_value = 3;
  inline bool has_consume_value() const;
  inline void clear_consume_value();
  static const int kConsumeValueFieldNumber = 3;
  inline ::google::protobuf::int32 consume_value() const;
  inline void set_consume_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:real.LevelUpCurve.Consume)
 private:
  inline void set_has_level_up();
  inline void clear_has_level_up();
  inline void set_has_consume_type();
  inline void clear_has_consume_type();
  inline void set_has_consume_value();
  inline void clear_has_consume_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 level_up_;
  int consume_type_;
  ::google::protobuf::int32 consume_value_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static LevelUpCurve_Consume* default_instance_;
};
// -------------------------------------------------------------------

class LevelUpCurve : public ::google::protobuf::Message {
 public:
  LevelUpCurve();
  virtual ~LevelUpCurve();

  LevelUpCurve(const LevelUpCurve& from);

  inline LevelUpCurve& operator=(const LevelUpCurve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LevelUpCurve& default_instance();

  void Swap(LevelUpCurve* other);

  // implements Message ----------------------------------------------

  LevelUpCurve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LevelUpCurve& from);
  void MergeFrom(const LevelUpCurve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LevelUpCurve_Consume Consume;

  // accessors -------------------------------------------------------

  // optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_LEVEL_UP];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::real::ConfigType type_t() const;
  inline void set_type_t(::real::ConfigType value);

  // optional .real.CCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::real::CCommonProp& common_prop() const;
  inline ::real::CCommonProp* mutable_common_prop();
  inline ::real::CCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::real::CCommonProp* common_prop);

  // repeated .real.LevelUpCurve.Consume consumes = 3;
  inline int consumes_size() const;
  inline void clear_consumes();
  static const int kConsumesFieldNumber = 3;
  inline const ::real::LevelUpCurve_Consume& consumes(int index) const;
  inline ::real::LevelUpCurve_Consume* mutable_consumes(int index);
  inline ::real::LevelUpCurve_Consume* add_consumes();
  inline const ::google::protobuf::RepeatedPtrField< ::real::LevelUpCurve_Consume >&
      consumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::real::LevelUpCurve_Consume >*
      mutable_consumes();

  // @@protoc_insertion_point(class_scope:real.LevelUpCurve)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::real::CCommonProp* common_prop_;
  ::google::protobuf::RepeatedPtrField< ::real::LevelUpCurve_Consume > consumes_;
  int type_t_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static LevelUpCurve* default_instance_;
};
// -------------------------------------------------------------------

class Scene : public ::google::protobuf::Message {
 public:
  Scene();
  virtual ~Scene();

  Scene(const Scene& from);

  inline Scene& operator=(const Scene& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scene& default_instance();

  void Swap(Scene* other);

  // implements Message ----------------------------------------------

  Scene* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scene& from);
  void MergeFrom(const Scene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_SCENE];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::real::ConfigType type_t() const;
  inline void set_type_t(::real::ConfigType value);

  // optional .real.CCommonProp common_prop = 2;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 2;
  inline const ::real::CCommonProp& common_prop() const;
  inline ::real::CCommonProp* mutable_common_prop();
  inline ::real::CCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::real::CCommonProp* common_prop);

  // optional int32 length = 3;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 3;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // optional int32 width = 4;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional string terrain_path = 5;
  inline bool has_terrain_path() const;
  inline void clear_terrain_path();
  static const int kTerrainPathFieldNumber = 5;
  inline const ::std::string& terrain_path() const;
  inline void set_terrain_path(const ::std::string& value);
  inline void set_terrain_path(const char* value);
  inline void set_terrain_path(const char* value, size_t size);
  inline ::std::string* mutable_terrain_path();
  inline ::std::string* release_terrain_path();
  inline void set_allocated_terrain_path(::std::string* terrain_path);

  // @@protoc_insertion_point(class_scope:real.Scene)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_terrain_path();
  inline void clear_has_terrain_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::real::CCommonProp* common_prop_;
  int type_t_;
  ::google::protobuf::int32 length_;
  ::std::string* terrain_path_;
  ::google::protobuf::int32 width_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static Scene* default_instance_;
};
// -------------------------------------------------------------------

class Item_CommonProp : public ::google::protobuf::Message {
 public:
  Item_CommonProp();
  virtual ~Item_CommonProp();

  Item_CommonProp(const Item_CommonProp& from);

  inline Item_CommonProp& operator=(const Item_CommonProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_CommonProp& default_instance();

  void Swap(Item_CommonProp* other);

  // implements Message ----------------------------------------------

  Item_CommonProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_CommonProp& from);
  void MergeFrom(const Item_CommonProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .real.CCommonProp common_prop = 1;
  inline bool has_common_prop() const;
  inline void clear_common_prop();
  static const int kCommonPropFieldNumber = 1;
  inline const ::real::CCommonProp& common_prop() const;
  inline ::real::CCommonProp* mutable_common_prop();
  inline ::real::CCommonProp* release_common_prop();
  inline void set_allocated_common_prop(::real::CCommonProp* common_prop);

  // optional string show_name = 2;
  inline bool has_show_name() const;
  inline void clear_show_name();
  static const int kShowNameFieldNumber = 2;
  inline const ::std::string& show_name() const;
  inline void set_show_name(const ::std::string& value);
  inline void set_show_name(const char* value);
  inline void set_show_name(const char* value, size_t size);
  inline ::std::string* mutable_show_name();
  inline ::std::string* release_show_name();
  inline void set_allocated_show_name(::std::string* show_name);

  // optional int32 quality = 3;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 3;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // optional int32 min_level_limit = 4;
  inline bool has_min_level_limit() const;
  inline void clear_min_level_limit();
  static const int kMinLevelLimitFieldNumber = 4;
  inline ::google::protobuf::int32 min_level_limit() const;
  inline void set_min_level_limit(::google::protobuf::int32 value);

  // optional int32 max_level_limit = 5;
  inline bool has_max_level_limit() const;
  inline void clear_max_level_limit();
  static const int kMaxLevelLimitFieldNumber = 5;
  inline ::google::protobuf::int32 max_level_limit() const;
  inline void set_max_level_limit(::google::protobuf::int32 value);

  // optional int32 pile_max = 6;
  inline bool has_pile_max() const;
  inline void clear_pile_max();
  static const int kPileMaxFieldNumber = 6;
  inline ::google::protobuf::int32 pile_max() const;
  inline void set_pile_max(::google::protobuf::int32 value);

  // optional int32 batch_use = 7;
  inline bool has_batch_use() const;
  inline void clear_batch_use();
  static const int kBatchUseFieldNumber = 7;
  inline ::google::protobuf::int32 batch_use() const;
  inline void set_batch_use(::google::protobuf::int32 value);

  // optional int32 auto_use = 8;
  inline bool has_auto_use() const;
  inline void clear_auto_use();
  static const int kAutoUseFieldNumber = 8;
  inline ::google::protobuf::int32 auto_use() const;
  inline void set_auto_use(::google::protobuf::int32 value);

  // optional int32 cool_down_id = 9;
  inline bool has_cool_down_id() const;
  inline void clear_cool_down_id();
  static const int kCoolDownIdFieldNumber = 9;
  inline ::google::protobuf::int32 cool_down_id() const;
  inline void set_cool_down_id(::google::protobuf::int32 value);

  // optional .real.InventoryType inventory = 10;
  inline bool has_inventory() const;
  inline void clear_inventory();
  static const int kInventoryFieldNumber = 10;
  inline ::real::InventoryType inventory() const;
  inline void set_inventory(::real::InventoryType value);

  // optional .real.ProfType prof_mask = 11;
  inline bool has_prof_mask() const;
  inline void clear_prof_mask();
  static const int kProfMaskFieldNumber = 11;
  inline ::real::ProfType prof_mask() const;
  inline void set_prof_mask(::real::ProfType value);

  // @@protoc_insertion_point(class_scope:real.Item_CommonProp)
 private:
  inline void set_has_common_prop();
  inline void clear_has_common_prop();
  inline void set_has_show_name();
  inline void clear_has_show_name();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_min_level_limit();
  inline void clear_has_min_level_limit();
  inline void set_has_max_level_limit();
  inline void clear_has_max_level_limit();
  inline void set_has_pile_max();
  inline void clear_has_pile_max();
  inline void set_has_batch_use();
  inline void clear_has_batch_use();
  inline void set_has_auto_use();
  inline void clear_has_auto_use();
  inline void set_has_cool_down_id();
  inline void clear_has_cool_down_id();
  inline void set_has_inventory();
  inline void clear_has_inventory();
  inline void set_has_prof_mask();
  inline void clear_has_prof_mask();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::real::CCommonProp* common_prop_;
  ::std::string* show_name_;
  ::google::protobuf::int32 quality_;
  ::google::protobuf::int32 min_level_limit_;
  ::google::protobuf::int32 max_level_limit_;
  ::google::protobuf::int32 pile_max_;
  ::google::protobuf::int32 batch_use_;
  ::google::protobuf::int32 auto_use_;
  ::google::protobuf::int32 cool_down_id_;
  int inventory_;
  int prof_mask_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static Item_CommonProp* default_instance_;
};
// -------------------------------------------------------------------

class Item_Item : public ::google::protobuf::Message {
 public:
  Item_Item();
  virtual ~Item_Item();

  Item_Item(const Item_Item& from);

  inline Item_Item& operator=(const Item_Item& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_Item& default_instance();

  void Swap(Item_Item* other);

  // implements Message ----------------------------------------------

  Item_Item* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_Item& from);
  void MergeFrom(const Item_Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .real.ConfigType type_t = 1 [default = ITEM_TYPE_BEGIN];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::real::ConfigType type_t() const;
  inline void set_type_t(::real::ConfigType value);

  // optional bytes stuff = 2;
  inline bool has_stuff() const;
  inline void clear_stuff();
  static const int kStuffFieldNumber = 2;
  inline const ::std::string& stuff() const;
  inline void set_stuff(const ::std::string& value);
  inline void set_stuff(const char* value);
  inline void set_stuff(const void* value, size_t size);
  inline ::std::string* mutable_stuff();
  inline ::std::string* release_stuff();
  inline void set_allocated_stuff(::std::string* stuff);

  // optional bytes stuff_extra = 3;
  inline bool has_stuff_extra() const;
  inline void clear_stuff_extra();
  static const int kStuffExtraFieldNumber = 3;
  inline const ::std::string& stuff_extra() const;
  inline void set_stuff_extra(const ::std::string& value);
  inline void set_stuff_extra(const char* value);
  inline void set_stuff_extra(const void* value, size_t size);
  inline ::std::string* mutable_stuff_extra();
  inline ::std::string* release_stuff_extra();
  inline void set_allocated_stuff_extra(::std::string* stuff_extra);

  // @@protoc_insertion_point(class_scope:real.Item_Item)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_stuff();
  inline void clear_has_stuff();
  inline void set_has_stuff_extra();
  inline void clear_has_stuff_extra();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* stuff_;
  ::std::string* stuff_extra_;
  int type_t_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static Item_Item* default_instance_;
};
// -------------------------------------------------------------------

class Item_Potion : public ::google::protobuf::Message {
 public:
  Item_Potion();
  virtual ~Item_Potion();

  Item_Potion(const Item_Potion& from);

  inline Item_Potion& operator=(const Item_Potion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_Potion& default_instance();

  void Swap(Item_Potion* other);

  // implements Message ----------------------------------------------

  Item_Potion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_Potion& from);
  void MergeFrom(const Item_Potion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Item_Potion_PotionType PotionType;
  static const PotionType POTION_TYPE_HEMO = Item_Potion_PotionType_POTION_TYPE_HEMO;
  static const PotionType POTION_TYPE_MAGIC = Item_Potion_PotionType_POTION_TYPE_MAGIC;
  static const PotionType POTION_TYPE_PHYSICAL_STRENGTH = Item_Potion_PotionType_POTION_TYPE_PHYSICAL_STRENGTH;
  static inline bool PotionType_IsValid(int value) {
    return Item_Potion_PotionType_IsValid(value);
  }
  static const PotionType PotionType_MIN =
    Item_Potion_PotionType_PotionType_MIN;
  static const PotionType PotionType_MAX =
    Item_Potion_PotionType_PotionType_MAX;
  static const int PotionType_ARRAYSIZE =
    Item_Potion_PotionType_PotionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PotionType_descriptor() {
    return Item_Potion_PotionType_descriptor();
  }
  static inline const ::std::string& PotionType_Name(PotionType value) {
    return Item_Potion_PotionType_Name(value);
  }
  static inline bool PotionType_Parse(const ::std::string& name,
      PotionType* value) {
    return Item_Potion_PotionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .real.ConfigType type_t = 1 [default = ITEM_TYPE_POTION];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::real::ConfigType type_t() const;
  inline void set_type_t(::real::ConfigType value);

  // optional .real.Item_CommonProp item_common_prop = 2;
  inline bool has_item_common_prop() const;
  inline void clear_item_common_prop();
  static const int kItemCommonPropFieldNumber = 2;
  inline const ::real::Item_CommonProp& item_common_prop() const;
  inline ::real::Item_CommonProp* mutable_item_common_prop();
  inline ::real::Item_CommonProp* release_item_common_prop();
  inline void set_allocated_item_common_prop(::real::Item_CommonProp* item_common_prop);

  // optional .real.Item_Potion.PotionType potion_type = 3;
  inline bool has_potion_type() const;
  inline void clear_potion_type();
  static const int kPotionTypeFieldNumber = 3;
  inline ::real::Item_Potion_PotionType potion_type() const;
  inline void set_potion_type(::real::Item_Potion_PotionType value);

  // optional int32 increase_value = 4;
  inline bool has_increase_value() const;
  inline void clear_increase_value();
  static const int kIncreaseValueFieldNumber = 4;
  inline ::google::protobuf::int32 increase_value() const;
  inline void set_increase_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:real.Item_Potion)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_item_common_prop();
  inline void clear_has_item_common_prop();
  inline void set_has_potion_type();
  inline void clear_has_potion_type();
  inline void set_has_increase_value();
  inline void clear_has_increase_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::real::Item_CommonProp* item_common_prop_;
  int type_t_;
  int potion_type_;
  ::google::protobuf::int32 increase_value_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static Item_Potion* default_instance_;
};
// -------------------------------------------------------------------

class Item_Equipment : public ::google::protobuf::Message {
 public:
  Item_Equipment();
  virtual ~Item_Equipment();

  Item_Equipment(const Item_Equipment& from);

  inline Item_Equipment& operator=(const Item_Equipment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Item_Equipment& default_instance();

  void Swap(Item_Equipment* other);

  // implements Message ----------------------------------------------

  Item_Equipment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Item_Equipment& from);
  void MergeFrom(const Item_Equipment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Item_Equipment_EuipType EuipType;
  static const EuipType EQUIP_TYPE_HELMET = Item_Equipment_EuipType_EQUIP_TYPE_HELMET;
  static inline bool EuipType_IsValid(int value) {
    return Item_Equipment_EuipType_IsValid(value);
  }
  static const EuipType EuipType_MIN =
    Item_Equipment_EuipType_EuipType_MIN;
  static const EuipType EuipType_MAX =
    Item_Equipment_EuipType_EuipType_MAX;
  static const int EuipType_ARRAYSIZE =
    Item_Equipment_EuipType_EuipType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EuipType_descriptor() {
    return Item_Equipment_EuipType_descriptor();
  }
  static inline const ::std::string& EuipType_Name(EuipType value) {
    return Item_Equipment_EuipType_Name(value);
  }
  static inline bool EuipType_Parse(const ::std::string& name,
      EuipType* value) {
    return Item_Equipment_EuipType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .real.ConfigType type_t = 1 [default = ITEM_TYPE_EQUIPMENT];
  inline bool has_type_t() const;
  inline void clear_type_t();
  static const int kTypeTFieldNumber = 1;
  inline ::real::ConfigType type_t() const;
  inline void set_type_t(::real::ConfigType value);

  // optional .real.Item_CommonProp item_common_prop = 2;
  inline bool has_item_common_prop() const;
  inline void clear_item_common_prop();
  static const int kItemCommonPropFieldNumber = 2;
  inline const ::real::Item_CommonProp& item_common_prop() const;
  inline ::real::Item_CommonProp* mutable_item_common_prop();
  inline ::real::Item_CommonProp* release_item_common_prop();
  inline void set_allocated_item_common_prop(::real::Item_CommonProp* item_common_prop);

  // optional .real.Item_Equipment.EuipType equip_type = 3;
  inline bool has_equip_type() const;
  inline void clear_equip_type();
  static const int kEquipTypeFieldNumber = 3;
  inline ::real::Item_Equipment_EuipType equip_type() const;
  inline void set_equip_type(::real::Item_Equipment_EuipType value);

  // @@protoc_insertion_point(class_scope:real.Item_Equipment)
 private:
  inline void set_has_type_t();
  inline void clear_has_type_t();
  inline void set_has_item_common_prop();
  inline void clear_has_item_common_prop();
  inline void set_has_equip_type();
  inline void clear_has_equip_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::real::Item_CommonProp* item_common_prop_;
  int type_t_;
  int equip_type_;
  friend void  protobuf_AddDesc_CommonConfig_2eproto();
  friend void protobuf_AssignDesc_CommonConfig_2eproto();
  friend void protobuf_ShutdownFile_CommonConfig_2eproto();

  void InitAsDefaultInstance();
  static Item_Equipment* default_instance_;
};
// ===================================================================

static const int kInventorySizeFieldNumber = 60000;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int32 >, 5, false >
  inventory_size;
static const int kRepeatedSizeFieldNumber = 60001;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int32 >, 5, false >
  repeated_size;

// ===================================================================

// Vector2

// optional float x = 1;
inline bool Vector2::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector2::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector2::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector2::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector2::x() const {
  // @@protoc_insertion_point(field_get:real.Vector2.x)
  return x_;
}
inline void Vector2::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:real.Vector2.x)
}

// optional float z = 2;
inline bool Vector2::has_z() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector2::set_has_z() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector2::clear_has_z() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector2::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector2::z() const {
  // @@protoc_insertion_point(field_get:real.Vector2.z)
  return z_;
}
inline void Vector2::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:real.Vector2.z)
}

// -------------------------------------------------------------------

// Vector3

// optional float x = 1;
inline bool Vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:real.Vector3.x)
  return x_;
}
inline void Vector3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:real.Vector3.x)
}

// optional float y = 2;
inline bool Vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:real.Vector3.y)
  return y_;
}
inline void Vector3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:real.Vector3.y)
}

// optional float z = 3;
inline bool Vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:real.Vector3.z)
  return z_;
}
inline void Vector3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:real.Vector3.z)
}

// -------------------------------------------------------------------

// CommonProp

// optional int64 id = 1;
inline bool CommonProp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonProp::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonProp::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonProp::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 CommonProp::id() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.id)
  return id_;
}
inline void CommonProp::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.id)
}

// optional .real.EntityType entity_type = 2;
inline bool CommonProp::has_entity_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonProp::set_has_entity_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonProp::clear_has_entity_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonProp::clear_entity_type() {
  entity_type_ = 1;
  clear_has_entity_type();
}
inline ::real::EntityType CommonProp::entity_type() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.entity_type)
  return static_cast< ::real::EntityType >(entity_type_);
}
inline void CommonProp::set_entity_type(::real::EntityType value) {
  assert(::real::EntityType_IsValid(value));
  set_has_entity_type();
  entity_type_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.entity_type)
}

// optional bytes name = 3;
inline bool CommonProp::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonProp::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonProp::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonProp::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CommonProp::name() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.name)
  return *name_;
}
inline void CommonProp::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:real.CommonProp.name)
}
inline void CommonProp::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:real.CommonProp.name)
}
inline void CommonProp::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:real.CommonProp.name)
}
inline ::std::string* CommonProp::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:real.CommonProp.name)
  return name_;
}
inline ::std::string* CommonProp::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CommonProp::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:real.CommonProp.name)
}

// optional int32 radius = 4;
inline bool CommonProp::has_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonProp::set_has_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonProp::clear_has_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonProp::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline ::google::protobuf::int32 CommonProp::radius() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.radius)
  return radius_;
}
inline void CommonProp::set_radius(::google::protobuf::int32 value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.radius)
}

// optional int32 height = 5;
inline bool CommonProp::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonProp::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonProp::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonProp::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 CommonProp::height() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.height)
  return height_;
}
inline void CommonProp::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.height)
}

// optional int32 level = 6;
inline bool CommonProp::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommonProp::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommonProp::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommonProp::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 CommonProp::level() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.level)
  return level_;
}
inline void CommonProp::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.level)
}

// optional int32 gender = 7;
inline bool CommonProp::has_gender() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommonProp::set_has_gender() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommonProp::clear_has_gender() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommonProp::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ::google::protobuf::int32 CommonProp::gender() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.gender)
  return gender_;
}
inline void CommonProp::set_gender(::google::protobuf::int32 value) {
  set_has_gender();
  gender_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.gender)
}

// optional int32 profession = 8;
inline bool CommonProp::has_profession() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommonProp::set_has_profession() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommonProp::clear_has_profession() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommonProp::clear_profession() {
  profession_ = 0;
  clear_has_profession();
}
inline ::google::protobuf::int32 CommonProp::profession() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.profession)
  return profession_;
}
inline void CommonProp::set_profession(::google::protobuf::int32 value) {
  set_has_profession();
  profession_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.profession)
}

// optional int32 speed = 9;
inline bool CommonProp::has_speed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommonProp::set_has_speed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommonProp::clear_has_speed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommonProp::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 CommonProp::speed() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.speed)
  return speed_;
}
inline void CommonProp::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.speed)
}

// optional int32 hp = 10;
inline bool CommonProp::has_hp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CommonProp::set_has_hp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CommonProp::clear_has_hp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CommonProp::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 CommonProp::hp() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.hp)
  return hp_;
}
inline void CommonProp::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.hp)
}

// optional int32 mp = 11;
inline bool CommonProp::has_mp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CommonProp::set_has_mp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CommonProp::clear_has_mp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CommonProp::clear_mp() {
  mp_ = 0;
  clear_has_mp();
}
inline ::google::protobuf::int32 CommonProp::mp() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.mp)
  return mp_;
}
inline void CommonProp::set_mp(::google::protobuf::int32 value) {
  set_has_mp();
  mp_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.mp)
}

// optional int32 orientation = 12;
inline bool CommonProp::has_orientation() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CommonProp::set_has_orientation() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CommonProp::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CommonProp::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
inline ::google::protobuf::int32 CommonProp::orientation() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.orientation)
  return orientation_;
}
inline void CommonProp::set_orientation(::google::protobuf::int32 value) {
  set_has_orientation();
  orientation_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.orientation)
}

// optional int32 scene_id = 13;
inline bool CommonProp::has_scene_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CommonProp::set_has_scene_id() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CommonProp::clear_has_scene_id() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CommonProp::clear_scene_id() {
  scene_id_ = 0;
  clear_has_scene_id();
}
inline ::google::protobuf::int32 CommonProp::scene_id() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.scene_id)
  return scene_id_;
}
inline void CommonProp::set_scene_id(::google::protobuf::int32 value) {
  set_has_scene_id();
  scene_id_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.scene_id)
}

// optional .real.Vector3 position = 14;
inline bool CommonProp::has_position() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CommonProp::set_has_position() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CommonProp::clear_has_position() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CommonProp::clear_position() {
  if (position_ != NULL) position_->::real::Vector3::Clear();
  clear_has_position();
}
inline const ::real::Vector3& CommonProp::position() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::real::Vector3* CommonProp::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::real::Vector3;
  // @@protoc_insertion_point(field_mutable:real.CommonProp.position)
  return position_;
}
inline ::real::Vector3* CommonProp::release_position() {
  clear_has_position();
  ::real::Vector3* temp = position_;
  position_ = NULL;
  return temp;
}
inline void CommonProp::set_allocated_position(::real::Vector3* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:real.CommonProp.position)
}

// optional float visibility_range = 15 [default = 90];
inline bool CommonProp::has_visibility_range() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CommonProp::set_has_visibility_range() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CommonProp::clear_has_visibility_range() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CommonProp::clear_visibility_range() {
  visibility_range_ = 90;
  clear_has_visibility_range();
}
inline float CommonProp::visibility_range() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.visibility_range)
  return visibility_range_;
}
inline void CommonProp::set_visibility_range(float value) {
  set_has_visibility_range();
  visibility_range_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.visibility_range)
}

// optional .real.CampType camp_type = 16;
inline bool CommonProp::has_camp_type() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CommonProp::set_has_camp_type() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CommonProp::clear_has_camp_type() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CommonProp::clear_camp_type() {
  camp_type_ = 1;
  clear_has_camp_type();
}
inline ::real::CampType CommonProp::camp_type() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.camp_type)
  return static_cast< ::real::CampType >(camp_type_);
}
inline void CommonProp::set_camp_type(::real::CampType value) {
  assert(::real::CampType_IsValid(value));
  set_has_camp_type();
  camp_type_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.camp_type)
}

// repeated int32 skills = 17;
inline int CommonProp::skills_size() const {
  return skills_.size();
}
inline void CommonProp::clear_skills() {
  skills_.Clear();
}
inline ::google::protobuf::int32 CommonProp::skills(int index) const {
  // @@protoc_insertion_point(field_get:real.CommonProp.skills)
  return skills_.Get(index);
}
inline void CommonProp::set_skills(int index, ::google::protobuf::int32 value) {
  skills_.Set(index, value);
  // @@protoc_insertion_point(field_set:real.CommonProp.skills)
}
inline void CommonProp::add_skills(::google::protobuf::int32 value) {
  skills_.Add(value);
  // @@protoc_insertion_point(field_add:real.CommonProp.skills)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CommonProp::skills() const {
  // @@protoc_insertion_point(field_list:real.CommonProp.skills)
  return skills_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CommonProp::mutable_skills() {
  // @@protoc_insertion_point(field_mutable_list:real.CommonProp.skills)
  return &skills_;
}

// optional int32 level_up_id = 18;
inline bool CommonProp::has_level_up_id() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CommonProp::set_has_level_up_id() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CommonProp::clear_has_level_up_id() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CommonProp::clear_level_up_id() {
  level_up_id_ = 0;
  clear_has_level_up_id();
}
inline ::google::protobuf::int32 CommonProp::level_up_id() const {
  // @@protoc_insertion_point(field_get:real.CommonProp.level_up_id)
  return level_up_id_;
}
inline void CommonProp::set_level_up_id(::google::protobuf::int32 value) {
  set_has_level_up_id();
  level_up_id_ = value;
  // @@protoc_insertion_point(field_set:real.CommonProp.level_up_id)
}

// -------------------------------------------------------------------

// CCommonProp

// required int32 id = 1;
inline bool CCommonProp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CCommonProp::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CCommonProp::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CCommonProp::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CCommonProp::id() const {
  // @@protoc_insertion_point(field_get:real.CCommonProp.id)
  return id_;
}
inline void CCommonProp::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:real.CCommonProp.id)
}

// required .real.Version version = 2;
inline bool CCommonProp::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CCommonProp::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CCommonProp::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CCommonProp::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::real::Version CCommonProp::version() const {
  // @@protoc_insertion_point(field_get:real.CCommonProp.version)
  return static_cast< ::real::Version >(version_);
}
inline void CCommonProp::set_version(::real::Version value) {
  assert(::real::Version_IsValid(value));
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:real.CCommonProp.version)
}

// optional string name = 3;
inline bool CCommonProp::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CCommonProp::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CCommonProp::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CCommonProp::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CCommonProp::name() const {
  // @@protoc_insertion_point(field_get:real.CCommonProp.name)
  return *name_;
}
inline void CCommonProp::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:real.CCommonProp.name)
}
inline void CCommonProp::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:real.CCommonProp.name)
}
inline void CCommonProp::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:real.CCommonProp.name)
}
inline ::std::string* CCommonProp::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:real.CCommonProp.name)
  return name_;
}
inline ::std::string* CCommonProp::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CCommonProp::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:real.CCommonProp.name)
}

// -------------------------------------------------------------------

// Plant

// optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_PLANT];
inline bool Plant::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Plant::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Plant::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Plant::clear_type_t() {
  type_t_ = 2;
  clear_has_type_t();
}
inline ::real::ConfigType Plant::type_t() const {
  // @@protoc_insertion_point(field_get:real.Plant.type_t)
  return static_cast< ::real::ConfigType >(type_t_);
}
inline void Plant::set_type_t(::real::ConfigType value) {
  assert(::real::ConfigType_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:real.Plant.type_t)
}

// optional .real.CCommonProp common_prop = 2;
inline bool Plant::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Plant::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Plant::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Plant::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::real::CCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::real::CCommonProp& Plant::common_prop() const {
  // @@protoc_insertion_point(field_get:real.Plant.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::real::CCommonProp* Plant::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::real::CCommonProp;
  // @@protoc_insertion_point(field_mutable:real.Plant.common_prop)
  return common_prop_;
}
inline ::real::CCommonProp* Plant::release_common_prop() {
  clear_has_common_prop();
  ::real::CCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Plant::set_allocated_common_prop(::real::CCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:real.Plant.common_prop)
}

// -------------------------------------------------------------------

// CommonLimit

// optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_COMMON_LIMIT];
inline bool CommonLimit::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonLimit::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonLimit::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonLimit::clear_type_t() {
  type_t_ = 3;
  clear_has_type_t();
}
inline ::real::ConfigType CommonLimit::type_t() const {
  // @@protoc_insertion_point(field_get:real.CommonLimit.type_t)
  return static_cast< ::real::ConfigType >(type_t_);
}
inline void CommonLimit::set_type_t(::real::ConfigType value) {
  assert(::real::ConfigType_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:real.CommonLimit.type_t)
}

// optional .real.CCommonProp common_prop = 2;
inline bool CommonLimit::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonLimit::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonLimit::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonLimit::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::real::CCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::real::CCommonProp& CommonLimit::common_prop() const {
  // @@protoc_insertion_point(field_get:real.CommonLimit.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::real::CCommonProp* CommonLimit::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::real::CCommonProp;
  // @@protoc_insertion_point(field_mutable:real.CommonLimit.common_prop)
  return common_prop_;
}
inline ::real::CCommonProp* CommonLimit::release_common_prop() {
  clear_has_common_prop();
  ::real::CCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void CommonLimit::set_allocated_common_prop(::real::CCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:real.CommonLimit.common_prop)
}

// optional .real.CommonLimit.CommonLimitType limit_type = 3;
inline bool CommonLimit::has_limit_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonLimit::set_has_limit_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonLimit::clear_has_limit_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonLimit::clear_limit_type() {
  limit_type_ = 1;
  clear_has_limit_type();
}
inline ::real::CommonLimit_CommonLimitType CommonLimit::limit_type() const {
  // @@protoc_insertion_point(field_get:real.CommonLimit.limit_type)
  return static_cast< ::real::CommonLimit_CommonLimitType >(limit_type_);
}
inline void CommonLimit::set_limit_type(::real::CommonLimit_CommonLimitType value) {
  assert(::real::CommonLimit_CommonLimitType_IsValid(value));
  set_has_limit_type();
  limit_type_ = value;
  // @@protoc_insertion_point(field_set:real.CommonLimit.limit_type)
}

// optional .real.CommonLimit.CoolDownType cool_down_type = 4;
inline bool CommonLimit::has_cool_down_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonLimit::set_has_cool_down_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonLimit::clear_has_cool_down_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonLimit::clear_cool_down_type() {
  cool_down_type_ = 1;
  clear_has_cool_down_type();
}
inline ::real::CommonLimit_CoolDownType CommonLimit::cool_down_type() const {
  // @@protoc_insertion_point(field_get:real.CommonLimit.cool_down_type)
  return static_cast< ::real::CommonLimit_CoolDownType >(cool_down_type_);
}
inline void CommonLimit::set_cool_down_type(::real::CommonLimit_CoolDownType value) {
  assert(::real::CommonLimit_CoolDownType_IsValid(value));
  set_has_cool_down_type();
  cool_down_type_ = value;
  // @@protoc_insertion_point(field_set:real.CommonLimit.cool_down_type)
}

// -------------------------------------------------------------------

// CoolDown

// optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_COOL_DOWN];
inline bool CoolDown::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoolDown::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoolDown::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoolDown::clear_type_t() {
  type_t_ = 5;
  clear_has_type_t();
}
inline ::real::ConfigType CoolDown::type_t() const {
  // @@protoc_insertion_point(field_get:real.CoolDown.type_t)
  return static_cast< ::real::ConfigType >(type_t_);
}
inline void CoolDown::set_type_t(::real::ConfigType value) {
  assert(::real::ConfigType_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:real.CoolDown.type_t)
}

// optional .real.CCommonProp common_prop = 2;
inline bool CoolDown::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoolDown::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoolDown::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoolDown::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::real::CCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::real::CCommonProp& CoolDown::common_prop() const {
  // @@protoc_insertion_point(field_get:real.CoolDown.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::real::CCommonProp* CoolDown::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::real::CCommonProp;
  // @@protoc_insertion_point(field_mutable:real.CoolDown.common_prop)
  return common_prop_;
}
inline ::real::CCommonProp* CoolDown::release_common_prop() {
  clear_has_common_prop();
  ::real::CCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void CoolDown::set_allocated_common_prop(::real::CCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:real.CoolDown.common_prop)
}

// optional int32 time = 3;
inline bool CoolDown::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoolDown::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoolDown::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoolDown::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 CoolDown::time() const {
  // @@protoc_insertion_point(field_get:real.CoolDown.time)
  return time_;
}
inline void CoolDown::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:real.CoolDown.time)
}

// -------------------------------------------------------------------

// Hoster

// optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_HOSTER];
inline bool Hoster::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hoster::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hoster::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hoster::clear_type_t() {
  type_t_ = 6;
  clear_has_type_t();
}
inline ::real::ConfigType Hoster::type_t() const {
  // @@protoc_insertion_point(field_get:real.Hoster.type_t)
  return static_cast< ::real::ConfigType >(type_t_);
}
inline void Hoster::set_type_t(::real::ConfigType value) {
  assert(::real::ConfigType_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:real.Hoster.type_t)
}

// optional .real.CCommonProp common_prop = 2;
inline bool Hoster::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hoster::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hoster::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hoster::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::real::CCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::real::CCommonProp& Hoster::common_prop() const {
  // @@protoc_insertion_point(field_get:real.Hoster.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::real::CCommonProp* Hoster::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::real::CCommonProp;
  // @@protoc_insertion_point(field_mutable:real.Hoster.common_prop)
  return common_prop_;
}
inline ::real::CCommonProp* Hoster::release_common_prop() {
  clear_has_common_prop();
  ::real::CCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Hoster::set_allocated_common_prop(::real::CCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:real.Hoster.common_prop)
}

// optional .real.CommonProp human_prop = 3;
inline bool Hoster::has_human_prop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hoster::set_has_human_prop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hoster::clear_has_human_prop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hoster::clear_human_prop() {
  if (human_prop_ != NULL) human_prop_->::real::CommonProp::Clear();
  clear_has_human_prop();
}
inline const ::real::CommonProp& Hoster::human_prop() const {
  // @@protoc_insertion_point(field_get:real.Hoster.human_prop)
  return human_prop_ != NULL ? *human_prop_ : *default_instance_->human_prop_;
}
inline ::real::CommonProp* Hoster::mutable_human_prop() {
  set_has_human_prop();
  if (human_prop_ == NULL) human_prop_ = new ::real::CommonProp;
  // @@protoc_insertion_point(field_mutable:real.Hoster.human_prop)
  return human_prop_;
}
inline ::real::CommonProp* Hoster::release_human_prop() {
  clear_has_human_prop();
  ::real::CommonProp* temp = human_prop_;
  human_prop_ = NULL;
  return temp;
}
inline void Hoster::set_allocated_human_prop(::real::CommonProp* human_prop) {
  delete human_prop_;
  human_prop_ = human_prop;
  if (human_prop) {
    set_has_human_prop();
  } else {
    clear_has_human_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:real.Hoster.human_prop)
}

// optional string behaviac_tree_path = 4;
inline bool Hoster::has_behaviac_tree_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hoster::set_has_behaviac_tree_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hoster::clear_has_behaviac_tree_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hoster::clear_behaviac_tree_path() {
  if (behaviac_tree_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_->clear();
  }
  clear_has_behaviac_tree_path();
}
inline const ::std::string& Hoster::behaviac_tree_path() const {
  // @@protoc_insertion_point(field_get:real.Hoster.behaviac_tree_path)
  return *behaviac_tree_path_;
}
inline void Hoster::set_behaviac_tree_path(const ::std::string& value) {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  behaviac_tree_path_->assign(value);
  // @@protoc_insertion_point(field_set:real.Hoster.behaviac_tree_path)
}
inline void Hoster::set_behaviac_tree_path(const char* value) {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  behaviac_tree_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:real.Hoster.behaviac_tree_path)
}
inline void Hoster::set_behaviac_tree_path(const char* value, size_t size) {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  behaviac_tree_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:real.Hoster.behaviac_tree_path)
}
inline ::std::string* Hoster::mutable_behaviac_tree_path() {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:real.Hoster.behaviac_tree_path)
  return behaviac_tree_path_;
}
inline ::std::string* Hoster::release_behaviac_tree_path() {
  clear_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = behaviac_tree_path_;
    behaviac_tree_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Hoster::set_allocated_behaviac_tree_path(::std::string* behaviac_tree_path) {
  if (behaviac_tree_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete behaviac_tree_path_;
  }
  if (behaviac_tree_path) {
    set_has_behaviac_tree_path();
    behaviac_tree_path_ = behaviac_tree_path;
  } else {
    clear_has_behaviac_tree_path();
    behaviac_tree_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:real.Hoster.behaviac_tree_path)
}

// optional int32 build_time = 5;
inline bool Hoster::has_build_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Hoster::set_has_build_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Hoster::clear_has_build_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Hoster::clear_build_time() {
  build_time_ = 0;
  clear_has_build_time();
}
inline ::google::protobuf::int32 Hoster::build_time() const {
  // @@protoc_insertion_point(field_get:real.Hoster.build_time)
  return build_time_;
}
inline void Hoster::set_build_time(::google::protobuf::int32 value) {
  set_has_build_time();
  build_time_ = value;
  // @@protoc_insertion_point(field_set:real.Hoster.build_time)
}

// optional int32 attack_speed = 6;
inline bool Hoster::has_attack_speed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Hoster::set_has_attack_speed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Hoster::clear_has_attack_speed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Hoster::clear_attack_speed() {
  attack_speed_ = 0;
  clear_has_attack_speed();
}
inline ::google::protobuf::int32 Hoster::attack_speed() const {
  // @@protoc_insertion_point(field_get:real.Hoster.attack_speed)
  return attack_speed_;
}
inline void Hoster::set_attack_speed(::google::protobuf::int32 value) {
  set_has_attack_speed();
  attack_speed_ = value;
  // @@protoc_insertion_point(field_set:real.Hoster.attack_speed)
}

// optional int32 produce_entity_id = 7;
inline bool Hoster::has_produce_entity_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Hoster::set_has_produce_entity_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Hoster::clear_has_produce_entity_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Hoster::clear_produce_entity_id() {
  produce_entity_id_ = 0;
  clear_has_produce_entity_id();
}
inline ::google::protobuf::int32 Hoster::produce_entity_id() const {
  // @@protoc_insertion_point(field_get:real.Hoster.produce_entity_id)
  return produce_entity_id_;
}
inline void Hoster::set_produce_entity_id(::google::protobuf::int32 value) {
  set_has_produce_entity_id();
  produce_entity_id_ = value;
  // @@protoc_insertion_point(field_set:real.Hoster.produce_entity_id)
}

// optional int32 produce_entity_speed = 8;
inline bool Hoster::has_produce_entity_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Hoster::set_has_produce_entity_speed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Hoster::clear_has_produce_entity_speed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Hoster::clear_produce_entity_speed() {
  produce_entity_speed_ = 0;
  clear_has_produce_entity_speed();
}
inline ::google::protobuf::int32 Hoster::produce_entity_speed() const {
  // @@protoc_insertion_point(field_get:real.Hoster.produce_entity_speed)
  return produce_entity_speed_;
}
inline void Hoster::set_produce_entity_speed(::google::protobuf::int32 value) {
  set_has_produce_entity_speed();
  produce_entity_speed_ = value;
  // @@protoc_insertion_point(field_set:real.Hoster.produce_entity_speed)
}

// optional int32 produce_entity_count = 9;
inline bool Hoster::has_produce_entity_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Hoster::set_has_produce_entity_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Hoster::clear_has_produce_entity_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Hoster::clear_produce_entity_count() {
  produce_entity_count_ = 0;
  clear_has_produce_entity_count();
}
inline ::google::protobuf::int32 Hoster::produce_entity_count() const {
  // @@protoc_insertion_point(field_get:real.Hoster.produce_entity_count)
  return produce_entity_count_;
}
inline void Hoster::set_produce_entity_count(::google::protobuf::int32 value) {
  set_has_produce_entity_count();
  produce_entity_count_ = value;
  // @@protoc_insertion_point(field_set:real.Hoster.produce_entity_count)
}

// -------------------------------------------------------------------

// Harm

// optional .real.Harm.HarmType harm_type = 1;
inline bool Harm::has_harm_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Harm::set_has_harm_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Harm::clear_has_harm_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Harm::clear_harm_type() {
  harm_type_ = 1;
  clear_has_harm_type();
}
inline ::real::Harm_HarmType Harm::harm_type() const {
  // @@protoc_insertion_point(field_get:real.Harm.harm_type)
  return static_cast< ::real::Harm_HarmType >(harm_type_);
}
inline void Harm::set_harm_type(::real::Harm_HarmType value) {
  assert(::real::Harm_HarmType_IsValid(value));
  set_has_harm_type();
  harm_type_ = value;
  // @@protoc_insertion_point(field_set:real.Harm.harm_type)
}

// optional int32 harm_total = 2;
inline bool Harm::has_harm_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Harm::set_has_harm_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Harm::clear_has_harm_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Harm::clear_harm_total() {
  harm_total_ = 0;
  clear_has_harm_total();
}
inline ::google::protobuf::int32 Harm::harm_total() const {
  // @@protoc_insertion_point(field_get:real.Harm.harm_total)
  return harm_total_;
}
inline void Harm::set_harm_total(::google::protobuf::int32 value) {
  set_has_harm_total();
  harm_total_ = value;
  // @@protoc_insertion_point(field_set:real.Harm.harm_total)
}

// optional int32 last_time = 3;
inline bool Harm::has_last_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Harm::set_has_last_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Harm::clear_has_last_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Harm::clear_last_time() {
  last_time_ = 0;
  clear_has_last_time();
}
inline ::google::protobuf::int32 Harm::last_time() const {
  // @@protoc_insertion_point(field_get:real.Harm.last_time)
  return last_time_;
}
inline void Harm::set_last_time(::google::protobuf::int32 value) {
  set_has_last_time();
  last_time_ = value;
  // @@protoc_insertion_point(field_set:real.Harm.last_time)
}

// optional int32 harm_per_second = 4;
inline bool Harm::has_harm_per_second() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Harm::set_has_harm_per_second() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Harm::clear_has_harm_per_second() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Harm::clear_harm_per_second() {
  harm_per_second_ = 0;
  clear_has_harm_per_second();
}
inline ::google::protobuf::int32 Harm::harm_per_second() const {
  // @@protoc_insertion_point(field_get:real.Harm.harm_per_second)
  return harm_per_second_;
}
inline void Harm::set_harm_per_second(::google::protobuf::int32 value) {
  set_has_harm_per_second();
  harm_per_second_ = value;
  // @@protoc_insertion_point(field_set:real.Harm.harm_per_second)
}

// optional int32 harm_range = 5;
inline bool Harm::has_harm_range() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Harm::set_has_harm_range() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Harm::clear_has_harm_range() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Harm::clear_harm_range() {
  harm_range_ = 0;
  clear_has_harm_range();
}
inline ::google::protobuf::int32 Harm::harm_range() const {
  // @@protoc_insertion_point(field_get:real.Harm.harm_range)
  return harm_range_;
}
inline void Harm::set_harm_range(::google::protobuf::int32 value) {
  set_has_harm_range();
  harm_range_ = value;
  // @@protoc_insertion_point(field_set:real.Harm.harm_range)
}

// optional .real.EntityType harm_target = 6;
inline bool Harm::has_harm_target() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Harm::set_has_harm_target() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Harm::clear_has_harm_target() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Harm::clear_harm_target() {
  harm_target_ = 1;
  clear_has_harm_target();
}
inline ::real::EntityType Harm::harm_target() const {
  // @@protoc_insertion_point(field_get:real.Harm.harm_target)
  return static_cast< ::real::EntityType >(harm_target_);
}
inline void Harm::set_harm_target(::real::EntityType value) {
  assert(::real::EntityType_IsValid(value));
  set_has_harm_target();
  harm_target_ = value;
  // @@protoc_insertion_point(field_set:real.Harm.harm_target)
}

// -------------------------------------------------------------------

// Skill

// optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_SKILL];
inline bool Skill::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Skill::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Skill::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Skill::clear_type_t() {
  type_t_ = 7;
  clear_has_type_t();
}
inline ::real::ConfigType Skill::type_t() const {
  // @@protoc_insertion_point(field_get:real.Skill.type_t)
  return static_cast< ::real::ConfigType >(type_t_);
}
inline void Skill::set_type_t(::real::ConfigType value) {
  assert(::real::ConfigType_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:real.Skill.type_t)
}

// optional .real.CCommonProp common_prop = 2;
inline bool Skill::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Skill::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Skill::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Skill::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::real::CCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::real::CCommonProp& Skill::common_prop() const {
  // @@protoc_insertion_point(field_get:real.Skill.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::real::CCommonProp* Skill::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::real::CCommonProp;
  // @@protoc_insertion_point(field_mutable:real.Skill.common_prop)
  return common_prop_;
}
inline ::real::CCommonProp* Skill::release_common_prop() {
  clear_has_common_prop();
  ::real::CCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Skill::set_allocated_common_prop(::real::CCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:real.Skill.common_prop)
}

// optional int32 level = 3;
inline bool Skill::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Skill::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Skill::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Skill::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 Skill::level() const {
  // @@protoc_insertion_point(field_get:real.Skill.level)
  return level_;
}
inline void Skill::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:real.Skill.level)
}

// optional string behaviac_tree_path = 4;
inline bool Skill::has_behaviac_tree_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Skill::set_has_behaviac_tree_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Skill::clear_has_behaviac_tree_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Skill::clear_behaviac_tree_path() {
  if (behaviac_tree_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_->clear();
  }
  clear_has_behaviac_tree_path();
}
inline const ::std::string& Skill::behaviac_tree_path() const {
  // @@protoc_insertion_point(field_get:real.Skill.behaviac_tree_path)
  return *behaviac_tree_path_;
}
inline void Skill::set_behaviac_tree_path(const ::std::string& value) {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  behaviac_tree_path_->assign(value);
  // @@protoc_insertion_point(field_set:real.Skill.behaviac_tree_path)
}
inline void Skill::set_behaviac_tree_path(const char* value) {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  behaviac_tree_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:real.Skill.behaviac_tree_path)
}
inline void Skill::set_behaviac_tree_path(const char* value, size_t size) {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  behaviac_tree_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:real.Skill.behaviac_tree_path)
}
inline ::std::string* Skill::mutable_behaviac_tree_path() {
  set_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    behaviac_tree_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:real.Skill.behaviac_tree_path)
  return behaviac_tree_path_;
}
inline ::std::string* Skill::release_behaviac_tree_path() {
  clear_has_behaviac_tree_path();
  if (behaviac_tree_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = behaviac_tree_path_;
    behaviac_tree_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Skill::set_allocated_behaviac_tree_path(::std::string* behaviac_tree_path) {
  if (behaviac_tree_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete behaviac_tree_path_;
  }
  if (behaviac_tree_path) {
    set_has_behaviac_tree_path();
    behaviac_tree_path_ = behaviac_tree_path;
  } else {
    clear_has_behaviac_tree_path();
    behaviac_tree_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:real.Skill.behaviac_tree_path)
}

// optional int32 cool_down_id = 5;
inline bool Skill::has_cool_down_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Skill::set_has_cool_down_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Skill::clear_has_cool_down_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Skill::clear_cool_down_id() {
  cool_down_id_ = 0;
  clear_has_cool_down_id();
}
inline ::google::protobuf::int32 Skill::cool_down_id() const {
  // @@protoc_insertion_point(field_get:real.Skill.cool_down_id)
  return cool_down_id_;
}
inline void Skill::set_cool_down_id(::google::protobuf::int32 value) {
  set_has_cool_down_id();
  cool_down_id_ = value;
  // @@protoc_insertion_point(field_set:real.Skill.cool_down_id)
}

// optional int32 defense = 6;
inline bool Skill::has_defense() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Skill::set_has_defense() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Skill::clear_has_defense() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Skill::clear_defense() {
  defense_ = 0;
  clear_has_defense();
}
inline ::google::protobuf::int32 Skill::defense() const {
  // @@protoc_insertion_point(field_get:real.Skill.defense)
  return defense_;
}
inline void Skill::set_defense(::google::protobuf::int32 value) {
  set_has_defense();
  defense_ = value;
  // @@protoc_insertion_point(field_set:real.Skill.defense)
}

// optional .real.Harm harm = 7;
inline bool Skill::has_harm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Skill::set_has_harm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Skill::clear_has_harm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Skill::clear_harm() {
  if (harm_ != NULL) harm_->::real::Harm::Clear();
  clear_has_harm();
}
inline const ::real::Harm& Skill::harm() const {
  // @@protoc_insertion_point(field_get:real.Skill.harm)
  return harm_ != NULL ? *harm_ : *default_instance_->harm_;
}
inline ::real::Harm* Skill::mutable_harm() {
  set_has_harm();
  if (harm_ == NULL) harm_ = new ::real::Harm;
  // @@protoc_insertion_point(field_mutable:real.Skill.harm)
  return harm_;
}
inline ::real::Harm* Skill::release_harm() {
  clear_has_harm();
  ::real::Harm* temp = harm_;
  harm_ = NULL;
  return temp;
}
inline void Skill::set_allocated_harm(::real::Harm* harm) {
  delete harm_;
  harm_ = harm;
  if (harm) {
    set_has_harm();
  } else {
    clear_has_harm();
  }
  // @@protoc_insertion_point(field_set_allocated:real.Skill.harm)
}

// optional int32 summon_entity_id = 8;
inline bool Skill::has_summon_entity_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Skill::set_has_summon_entity_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Skill::clear_has_summon_entity_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Skill::clear_summon_entity_id() {
  summon_entity_id_ = 0;
  clear_has_summon_entity_id();
}
inline ::google::protobuf::int32 Skill::summon_entity_id() const {
  // @@protoc_insertion_point(field_get:real.Skill.summon_entity_id)
  return summon_entity_id_;
}
inline void Skill::set_summon_entity_id(::google::protobuf::int32 value) {
  set_has_summon_entity_id();
  summon_entity_id_ = value;
  // @@protoc_insertion_point(field_set:real.Skill.summon_entity_id)
}

// optional int32 death_harm_total = 9;
inline bool Skill::has_death_harm_total() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Skill::set_has_death_harm_total() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Skill::clear_has_death_harm_total() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Skill::clear_death_harm_total() {
  death_harm_total_ = 0;
  clear_has_death_harm_total();
}
inline ::google::protobuf::int32 Skill::death_harm_total() const {
  // @@protoc_insertion_point(field_get:real.Skill.death_harm_total)
  return death_harm_total_;
}
inline void Skill::set_death_harm_total(::google::protobuf::int32 value) {
  set_has_death_harm_total();
  death_harm_total_ = value;
  // @@protoc_insertion_point(field_set:real.Skill.death_harm_total)
}

// -------------------------------------------------------------------

// LevelUpCurve_Consume

// optional int32 level_up = 1;
inline bool LevelUpCurve_Consume::has_level_up() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LevelUpCurve_Consume::set_has_level_up() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LevelUpCurve_Consume::clear_has_level_up() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LevelUpCurve_Consume::clear_level_up() {
  level_up_ = 0;
  clear_has_level_up();
}
inline ::google::protobuf::int32 LevelUpCurve_Consume::level_up() const {
  // @@protoc_insertion_point(field_get:real.LevelUpCurve.Consume.level_up)
  return level_up_;
}
inline void LevelUpCurve_Consume::set_level_up(::google::protobuf::int32 value) {
  set_has_level_up();
  level_up_ = value;
  // @@protoc_insertion_point(field_set:real.LevelUpCurve.Consume.level_up)
}

// optional .real.LevelUpCurve.Consume.CosumeType consume_type = 2;
inline bool LevelUpCurve_Consume::has_consume_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LevelUpCurve_Consume::set_has_consume_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LevelUpCurve_Consume::clear_has_consume_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LevelUpCurve_Consume::clear_consume_type() {
  consume_type_ = 1;
  clear_has_consume_type();
}
inline ::real::LevelUpCurve_Consume_CosumeType LevelUpCurve_Consume::consume_type() const {
  // @@protoc_insertion_point(field_get:real.LevelUpCurve.Consume.consume_type)
  return static_cast< ::real::LevelUpCurve_Consume_CosumeType >(consume_type_);
}
inline void LevelUpCurve_Consume::set_consume_type(::real::LevelUpCurve_Consume_CosumeType value) {
  assert(::real::LevelUpCurve_Consume_CosumeType_IsValid(value));
  set_has_consume_type();
  consume_type_ = value;
  // @@protoc_insertion_point(field_set:real.LevelUpCurve.Consume.consume_type)
}

// optional int32 consume_value = 3;
inline bool LevelUpCurve_Consume::has_consume_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LevelUpCurve_Consume::set_has_consume_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LevelUpCurve_Consume::clear_has_consume_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LevelUpCurve_Consume::clear_consume_value() {
  consume_value_ = 0;
  clear_has_consume_value();
}
inline ::google::protobuf::int32 LevelUpCurve_Consume::consume_value() const {
  // @@protoc_insertion_point(field_get:real.LevelUpCurve.Consume.consume_value)
  return consume_value_;
}
inline void LevelUpCurve_Consume::set_consume_value(::google::protobuf::int32 value) {
  set_has_consume_value();
  consume_value_ = value;
  // @@protoc_insertion_point(field_set:real.LevelUpCurve.Consume.consume_value)
}

// -------------------------------------------------------------------

// LevelUpCurve

// optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_LEVEL_UP];
inline bool LevelUpCurve::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LevelUpCurve::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LevelUpCurve::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LevelUpCurve::clear_type_t() {
  type_t_ = 8;
  clear_has_type_t();
}
inline ::real::ConfigType LevelUpCurve::type_t() const {
  // @@protoc_insertion_point(field_get:real.LevelUpCurve.type_t)
  return static_cast< ::real::ConfigType >(type_t_);
}
inline void LevelUpCurve::set_type_t(::real::ConfigType value) {
  assert(::real::ConfigType_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:real.LevelUpCurve.type_t)
}

// optional .real.CCommonProp common_prop = 2;
inline bool LevelUpCurve::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LevelUpCurve::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LevelUpCurve::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LevelUpCurve::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::real::CCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::real::CCommonProp& LevelUpCurve::common_prop() const {
  // @@protoc_insertion_point(field_get:real.LevelUpCurve.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::real::CCommonProp* LevelUpCurve::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::real::CCommonProp;
  // @@protoc_insertion_point(field_mutable:real.LevelUpCurve.common_prop)
  return common_prop_;
}
inline ::real::CCommonProp* LevelUpCurve::release_common_prop() {
  clear_has_common_prop();
  ::real::CCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void LevelUpCurve::set_allocated_common_prop(::real::CCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:real.LevelUpCurve.common_prop)
}

// repeated .real.LevelUpCurve.Consume consumes = 3;
inline int LevelUpCurve::consumes_size() const {
  return consumes_.size();
}
inline void LevelUpCurve::clear_consumes() {
  consumes_.Clear();
}
inline const ::real::LevelUpCurve_Consume& LevelUpCurve::consumes(int index) const {
  // @@protoc_insertion_point(field_get:real.LevelUpCurve.consumes)
  return consumes_.Get(index);
}
inline ::real::LevelUpCurve_Consume* LevelUpCurve::mutable_consumes(int index) {
  // @@protoc_insertion_point(field_mutable:real.LevelUpCurve.consumes)
  return consumes_.Mutable(index);
}
inline ::real::LevelUpCurve_Consume* LevelUpCurve::add_consumes() {
  // @@protoc_insertion_point(field_add:real.LevelUpCurve.consumes)
  return consumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::real::LevelUpCurve_Consume >&
LevelUpCurve::consumes() const {
  // @@protoc_insertion_point(field_list:real.LevelUpCurve.consumes)
  return consumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::real::LevelUpCurve_Consume >*
LevelUpCurve::mutable_consumes() {
  // @@protoc_insertion_point(field_mutable_list:real.LevelUpCurve.consumes)
  return &consumes_;
}

// -------------------------------------------------------------------

// Scene

// optional .real.ConfigType type_t = 1 [default = CONFIG_TYPE_SCENE];
inline bool Scene::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scene::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Scene::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Scene::clear_type_t() {
  type_t_ = 9;
  clear_has_type_t();
}
inline ::real::ConfigType Scene::type_t() const {
  // @@protoc_insertion_point(field_get:real.Scene.type_t)
  return static_cast< ::real::ConfigType >(type_t_);
}
inline void Scene::set_type_t(::real::ConfigType value) {
  assert(::real::ConfigType_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:real.Scene.type_t)
}

// optional .real.CCommonProp common_prop = 2;
inline bool Scene::has_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Scene::set_has_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Scene::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Scene::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::real::CCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::real::CCommonProp& Scene::common_prop() const {
  // @@protoc_insertion_point(field_get:real.Scene.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::real::CCommonProp* Scene::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::real::CCommonProp;
  // @@protoc_insertion_point(field_mutable:real.Scene.common_prop)
  return common_prop_;
}
inline ::real::CCommonProp* Scene::release_common_prop() {
  clear_has_common_prop();
  ::real::CCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Scene::set_allocated_common_prop(::real::CCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:real.Scene.common_prop)
}

// optional int32 length = 3;
inline bool Scene::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Scene::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Scene::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Scene::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 Scene::length() const {
  // @@protoc_insertion_point(field_get:real.Scene.length)
  return length_;
}
inline void Scene::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:real.Scene.length)
}

// optional int32 width = 4;
inline bool Scene::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Scene::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Scene::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Scene::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Scene::width() const {
  // @@protoc_insertion_point(field_get:real.Scene.width)
  return width_;
}
inline void Scene::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:real.Scene.width)
}

// optional string terrain_path = 5;
inline bool Scene::has_terrain_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Scene::set_has_terrain_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Scene::clear_has_terrain_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Scene::clear_terrain_path() {
  if (terrain_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    terrain_path_->clear();
  }
  clear_has_terrain_path();
}
inline const ::std::string& Scene::terrain_path() const {
  // @@protoc_insertion_point(field_get:real.Scene.terrain_path)
  return *terrain_path_;
}
inline void Scene::set_terrain_path(const ::std::string& value) {
  set_has_terrain_path();
  if (terrain_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    terrain_path_ = new ::std::string;
  }
  terrain_path_->assign(value);
  // @@protoc_insertion_point(field_set:real.Scene.terrain_path)
}
inline void Scene::set_terrain_path(const char* value) {
  set_has_terrain_path();
  if (terrain_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    terrain_path_ = new ::std::string;
  }
  terrain_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:real.Scene.terrain_path)
}
inline void Scene::set_terrain_path(const char* value, size_t size) {
  set_has_terrain_path();
  if (terrain_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    terrain_path_ = new ::std::string;
  }
  terrain_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:real.Scene.terrain_path)
}
inline ::std::string* Scene::mutable_terrain_path() {
  set_has_terrain_path();
  if (terrain_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    terrain_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:real.Scene.terrain_path)
  return terrain_path_;
}
inline ::std::string* Scene::release_terrain_path() {
  clear_has_terrain_path();
  if (terrain_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = terrain_path_;
    terrain_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Scene::set_allocated_terrain_path(::std::string* terrain_path) {
  if (terrain_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete terrain_path_;
  }
  if (terrain_path) {
    set_has_terrain_path();
    terrain_path_ = terrain_path;
  } else {
    clear_has_terrain_path();
    terrain_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:real.Scene.terrain_path)
}

// -------------------------------------------------------------------

// Item_CommonProp

// optional .real.CCommonProp common_prop = 1;
inline bool Item_CommonProp::has_common_prop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_CommonProp::set_has_common_prop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_CommonProp::clear_has_common_prop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_CommonProp::clear_common_prop() {
  if (common_prop_ != NULL) common_prop_->::real::CCommonProp::Clear();
  clear_has_common_prop();
}
inline const ::real::CCommonProp& Item_CommonProp::common_prop() const {
  // @@protoc_insertion_point(field_get:real.Item_CommonProp.common_prop)
  return common_prop_ != NULL ? *common_prop_ : *default_instance_->common_prop_;
}
inline ::real::CCommonProp* Item_CommonProp::mutable_common_prop() {
  set_has_common_prop();
  if (common_prop_ == NULL) common_prop_ = new ::real::CCommonProp;
  // @@protoc_insertion_point(field_mutable:real.Item_CommonProp.common_prop)
  return common_prop_;
}
inline ::real::CCommonProp* Item_CommonProp::release_common_prop() {
  clear_has_common_prop();
  ::real::CCommonProp* temp = common_prop_;
  common_prop_ = NULL;
  return temp;
}
inline void Item_CommonProp::set_allocated_common_prop(::real::CCommonProp* common_prop) {
  delete common_prop_;
  common_prop_ = common_prop;
  if (common_prop) {
    set_has_common_prop();
  } else {
    clear_has_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:real.Item_CommonProp.common_prop)
}

// optional string show_name = 2;
inline bool Item_CommonProp::has_show_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_CommonProp::set_has_show_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_CommonProp::clear_has_show_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_CommonProp::clear_show_name() {
  if (show_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_->clear();
  }
  clear_has_show_name();
}
inline const ::std::string& Item_CommonProp::show_name() const {
  // @@protoc_insertion_point(field_get:real.Item_CommonProp.show_name)
  return *show_name_;
}
inline void Item_CommonProp::set_show_name(const ::std::string& value) {
  set_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_ = new ::std::string;
  }
  show_name_->assign(value);
  // @@protoc_insertion_point(field_set:real.Item_CommonProp.show_name)
}
inline void Item_CommonProp::set_show_name(const char* value) {
  set_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_ = new ::std::string;
  }
  show_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:real.Item_CommonProp.show_name)
}
inline void Item_CommonProp::set_show_name(const char* value, size_t size) {
  set_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_ = new ::std::string;
  }
  show_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:real.Item_CommonProp.show_name)
}
inline ::std::string* Item_CommonProp::mutable_show_name() {
  set_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    show_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:real.Item_CommonProp.show_name)
  return show_name_;
}
inline ::std::string* Item_CommonProp::release_show_name() {
  clear_has_show_name();
  if (show_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = show_name_;
    show_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Item_CommonProp::set_allocated_show_name(::std::string* show_name) {
  if (show_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete show_name_;
  }
  if (show_name) {
    set_has_show_name();
    show_name_ = show_name;
  } else {
    clear_has_show_name();
    show_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:real.Item_CommonProp.show_name)
}

// optional int32 quality = 3;
inline bool Item_CommonProp::has_quality() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item_CommonProp::set_has_quality() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item_CommonProp::clear_has_quality() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item_CommonProp::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 Item_CommonProp::quality() const {
  // @@protoc_insertion_point(field_get:real.Item_CommonProp.quality)
  return quality_;
}
inline void Item_CommonProp::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
  // @@protoc_insertion_point(field_set:real.Item_CommonProp.quality)
}

// optional int32 min_level_limit = 4;
inline bool Item_CommonProp::has_min_level_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Item_CommonProp::set_has_min_level_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Item_CommonProp::clear_has_min_level_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Item_CommonProp::clear_min_level_limit() {
  min_level_limit_ = 0;
  clear_has_min_level_limit();
}
inline ::google::protobuf::int32 Item_CommonProp::min_level_limit() const {
  // @@protoc_insertion_point(field_get:real.Item_CommonProp.min_level_limit)
  return min_level_limit_;
}
inline void Item_CommonProp::set_min_level_limit(::google::protobuf::int32 value) {
  set_has_min_level_limit();
  min_level_limit_ = value;
  // @@protoc_insertion_point(field_set:real.Item_CommonProp.min_level_limit)
}

// optional int32 max_level_limit = 5;
inline bool Item_CommonProp::has_max_level_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Item_CommonProp::set_has_max_level_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Item_CommonProp::clear_has_max_level_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Item_CommonProp::clear_max_level_limit() {
  max_level_limit_ = 0;
  clear_has_max_level_limit();
}
inline ::google::protobuf::int32 Item_CommonProp::max_level_limit() const {
  // @@protoc_insertion_point(field_get:real.Item_CommonProp.max_level_limit)
  return max_level_limit_;
}
inline void Item_CommonProp::set_max_level_limit(::google::protobuf::int32 value) {
  set_has_max_level_limit();
  max_level_limit_ = value;
  // @@protoc_insertion_point(field_set:real.Item_CommonProp.max_level_limit)
}

// optional int32 pile_max = 6;
inline bool Item_CommonProp::has_pile_max() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Item_CommonProp::set_has_pile_max() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Item_CommonProp::clear_has_pile_max() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Item_CommonProp::clear_pile_max() {
  pile_max_ = 0;
  clear_has_pile_max();
}
inline ::google::protobuf::int32 Item_CommonProp::pile_max() const {
  // @@protoc_insertion_point(field_get:real.Item_CommonProp.pile_max)
  return pile_max_;
}
inline void Item_CommonProp::set_pile_max(::google::protobuf::int32 value) {
  set_has_pile_max();
  pile_max_ = value;
  // @@protoc_insertion_point(field_set:real.Item_CommonProp.pile_max)
}

// optional int32 batch_use = 7;
inline bool Item_CommonProp::has_batch_use() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Item_CommonProp::set_has_batch_use() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Item_CommonProp::clear_has_batch_use() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Item_CommonProp::clear_batch_use() {
  batch_use_ = 0;
  clear_has_batch_use();
}
inline ::google::protobuf::int32 Item_CommonProp::batch_use() const {
  // @@protoc_insertion_point(field_get:real.Item_CommonProp.batch_use)
  return batch_use_;
}
inline void Item_CommonProp::set_batch_use(::google::protobuf::int32 value) {
  set_has_batch_use();
  batch_use_ = value;
  // @@protoc_insertion_point(field_set:real.Item_CommonProp.batch_use)
}

// optional int32 auto_use = 8;
inline bool Item_CommonProp::has_auto_use() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Item_CommonProp::set_has_auto_use() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Item_CommonProp::clear_has_auto_use() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Item_CommonProp::clear_auto_use() {
  auto_use_ = 0;
  clear_has_auto_use();
}
inline ::google::protobuf::int32 Item_CommonProp::auto_use() const {
  // @@protoc_insertion_point(field_get:real.Item_CommonProp.auto_use)
  return auto_use_;
}
inline void Item_CommonProp::set_auto_use(::google::protobuf::int32 value) {
  set_has_auto_use();
  auto_use_ = value;
  // @@protoc_insertion_point(field_set:real.Item_CommonProp.auto_use)
}

// optional int32 cool_down_id = 9;
inline bool Item_CommonProp::has_cool_down_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Item_CommonProp::set_has_cool_down_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Item_CommonProp::clear_has_cool_down_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Item_CommonProp::clear_cool_down_id() {
  cool_down_id_ = 0;
  clear_has_cool_down_id();
}
inline ::google::protobuf::int32 Item_CommonProp::cool_down_id() const {
  // @@protoc_insertion_point(field_get:real.Item_CommonProp.cool_down_id)
  return cool_down_id_;
}
inline void Item_CommonProp::set_cool_down_id(::google::protobuf::int32 value) {
  set_has_cool_down_id();
  cool_down_id_ = value;
  // @@protoc_insertion_point(field_set:real.Item_CommonProp.cool_down_id)
}

// optional .real.InventoryType inventory = 10;
inline bool Item_CommonProp::has_inventory() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Item_CommonProp::set_has_inventory() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Item_CommonProp::clear_has_inventory() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Item_CommonProp::clear_inventory() {
  inventory_ = 1;
  clear_has_inventory();
}
inline ::real::InventoryType Item_CommonProp::inventory() const {
  // @@protoc_insertion_point(field_get:real.Item_CommonProp.inventory)
  return static_cast< ::real::InventoryType >(inventory_);
}
inline void Item_CommonProp::set_inventory(::real::InventoryType value) {
  assert(::real::InventoryType_IsValid(value));
  set_has_inventory();
  inventory_ = value;
  // @@protoc_insertion_point(field_set:real.Item_CommonProp.inventory)
}

// optional .real.ProfType prof_mask = 11;
inline bool Item_CommonProp::has_prof_mask() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Item_CommonProp::set_has_prof_mask() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Item_CommonProp::clear_has_prof_mask() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Item_CommonProp::clear_prof_mask() {
  prof_mask_ = 1;
  clear_has_prof_mask();
}
inline ::real::ProfType Item_CommonProp::prof_mask() const {
  // @@protoc_insertion_point(field_get:real.Item_CommonProp.prof_mask)
  return static_cast< ::real::ProfType >(prof_mask_);
}
inline void Item_CommonProp::set_prof_mask(::real::ProfType value) {
  assert(::real::ProfType_IsValid(value));
  set_has_prof_mask();
  prof_mask_ = value;
  // @@protoc_insertion_point(field_set:real.Item_CommonProp.prof_mask)
}

// -------------------------------------------------------------------

// Item_Item

// optional .real.ConfigType type_t = 1 [default = ITEM_TYPE_BEGIN];
inline bool Item_Item::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_Item::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_Item::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_Item::clear_type_t() {
  type_t_ = 201;
  clear_has_type_t();
}
inline ::real::ConfigType Item_Item::type_t() const {
  // @@protoc_insertion_point(field_get:real.Item_Item.type_t)
  return static_cast< ::real::ConfigType >(type_t_);
}
inline void Item_Item::set_type_t(::real::ConfigType value) {
  assert(::real::ConfigType_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:real.Item_Item.type_t)
}

// optional bytes stuff = 2;
inline bool Item_Item::has_stuff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_Item::set_has_stuff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_Item::clear_has_stuff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_Item::clear_stuff() {
  if (stuff_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_->clear();
  }
  clear_has_stuff();
}
inline const ::std::string& Item_Item::stuff() const {
  // @@protoc_insertion_point(field_get:real.Item_Item.stuff)
  return *stuff_;
}
inline void Item_Item::set_stuff(const ::std::string& value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
  // @@protoc_insertion_point(field_set:real.Item_Item.stuff)
}
inline void Item_Item::set_stuff(const char* value) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(value);
  // @@protoc_insertion_point(field_set_char:real.Item_Item.stuff)
}
inline void Item_Item::set_stuff(const void* value, size_t size) {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  stuff_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:real.Item_Item.stuff)
}
inline ::std::string* Item_Item::mutable_stuff() {
  set_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:real.Item_Item.stuff)
  return stuff_;
}
inline ::std::string* Item_Item::release_stuff() {
  clear_has_stuff();
  if (stuff_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stuff_;
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Item_Item::set_allocated_stuff(::std::string* stuff) {
  if (stuff_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stuff_;
  }
  if (stuff) {
    set_has_stuff();
    stuff_ = stuff;
  } else {
    clear_has_stuff();
    stuff_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:real.Item_Item.stuff)
}

// optional bytes stuff_extra = 3;
inline bool Item_Item::has_stuff_extra() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item_Item::set_has_stuff_extra() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item_Item::clear_has_stuff_extra() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item_Item::clear_stuff_extra() {
  if (stuff_extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_->clear();
  }
  clear_has_stuff_extra();
}
inline const ::std::string& Item_Item::stuff_extra() const {
  // @@protoc_insertion_point(field_get:real.Item_Item.stuff_extra)
  return *stuff_extra_;
}
inline void Item_Item::set_stuff_extra(const ::std::string& value) {
  set_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_ = new ::std::string;
  }
  stuff_extra_->assign(value);
  // @@protoc_insertion_point(field_set:real.Item_Item.stuff_extra)
}
inline void Item_Item::set_stuff_extra(const char* value) {
  set_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_ = new ::std::string;
  }
  stuff_extra_->assign(value);
  // @@protoc_insertion_point(field_set_char:real.Item_Item.stuff_extra)
}
inline void Item_Item::set_stuff_extra(const void* value, size_t size) {
  set_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_ = new ::std::string;
  }
  stuff_extra_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:real.Item_Item.stuff_extra)
}
inline ::std::string* Item_Item::mutable_stuff_extra() {
  set_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stuff_extra_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:real.Item_Item.stuff_extra)
  return stuff_extra_;
}
inline ::std::string* Item_Item::release_stuff_extra() {
  clear_has_stuff_extra();
  if (stuff_extra_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stuff_extra_;
    stuff_extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Item_Item::set_allocated_stuff_extra(::std::string* stuff_extra) {
  if (stuff_extra_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stuff_extra_;
  }
  if (stuff_extra) {
    set_has_stuff_extra();
    stuff_extra_ = stuff_extra;
  } else {
    clear_has_stuff_extra();
    stuff_extra_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:real.Item_Item.stuff_extra)
}

// -------------------------------------------------------------------

// Item_Potion

// optional .real.ConfigType type_t = 1 [default = ITEM_TYPE_POTION];
inline bool Item_Potion::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_Potion::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_Potion::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_Potion::clear_type_t() {
  type_t_ = 202;
  clear_has_type_t();
}
inline ::real::ConfigType Item_Potion::type_t() const {
  // @@protoc_insertion_point(field_get:real.Item_Potion.type_t)
  return static_cast< ::real::ConfigType >(type_t_);
}
inline void Item_Potion::set_type_t(::real::ConfigType value) {
  assert(::real::ConfigType_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:real.Item_Potion.type_t)
}

// optional .real.Item_CommonProp item_common_prop = 2;
inline bool Item_Potion::has_item_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_Potion::set_has_item_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_Potion::clear_has_item_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_Potion::clear_item_common_prop() {
  if (item_common_prop_ != NULL) item_common_prop_->::real::Item_CommonProp::Clear();
  clear_has_item_common_prop();
}
inline const ::real::Item_CommonProp& Item_Potion::item_common_prop() const {
  // @@protoc_insertion_point(field_get:real.Item_Potion.item_common_prop)
  return item_common_prop_ != NULL ? *item_common_prop_ : *default_instance_->item_common_prop_;
}
inline ::real::Item_CommonProp* Item_Potion::mutable_item_common_prop() {
  set_has_item_common_prop();
  if (item_common_prop_ == NULL) item_common_prop_ = new ::real::Item_CommonProp;
  // @@protoc_insertion_point(field_mutable:real.Item_Potion.item_common_prop)
  return item_common_prop_;
}
inline ::real::Item_CommonProp* Item_Potion::release_item_common_prop() {
  clear_has_item_common_prop();
  ::real::Item_CommonProp* temp = item_common_prop_;
  item_common_prop_ = NULL;
  return temp;
}
inline void Item_Potion::set_allocated_item_common_prop(::real::Item_CommonProp* item_common_prop) {
  delete item_common_prop_;
  item_common_prop_ = item_common_prop;
  if (item_common_prop) {
    set_has_item_common_prop();
  } else {
    clear_has_item_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:real.Item_Potion.item_common_prop)
}

// optional .real.Item_Potion.PotionType potion_type = 3;
inline bool Item_Potion::has_potion_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item_Potion::set_has_potion_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item_Potion::clear_has_potion_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item_Potion::clear_potion_type() {
  potion_type_ = 1;
  clear_has_potion_type();
}
inline ::real::Item_Potion_PotionType Item_Potion::potion_type() const {
  // @@protoc_insertion_point(field_get:real.Item_Potion.potion_type)
  return static_cast< ::real::Item_Potion_PotionType >(potion_type_);
}
inline void Item_Potion::set_potion_type(::real::Item_Potion_PotionType value) {
  assert(::real::Item_Potion_PotionType_IsValid(value));
  set_has_potion_type();
  potion_type_ = value;
  // @@protoc_insertion_point(field_set:real.Item_Potion.potion_type)
}

// optional int32 increase_value = 4;
inline bool Item_Potion::has_increase_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Item_Potion::set_has_increase_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Item_Potion::clear_has_increase_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Item_Potion::clear_increase_value() {
  increase_value_ = 0;
  clear_has_increase_value();
}
inline ::google::protobuf::int32 Item_Potion::increase_value() const {
  // @@protoc_insertion_point(field_get:real.Item_Potion.increase_value)
  return increase_value_;
}
inline void Item_Potion::set_increase_value(::google::protobuf::int32 value) {
  set_has_increase_value();
  increase_value_ = value;
  // @@protoc_insertion_point(field_set:real.Item_Potion.increase_value)
}

// -------------------------------------------------------------------

// Item_Equipment

// optional .real.ConfigType type_t = 1 [default = ITEM_TYPE_EQUIPMENT];
inline bool Item_Equipment::has_type_t() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item_Equipment::set_has_type_t() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item_Equipment::clear_has_type_t() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item_Equipment::clear_type_t() {
  type_t_ = 203;
  clear_has_type_t();
}
inline ::real::ConfigType Item_Equipment::type_t() const {
  // @@protoc_insertion_point(field_get:real.Item_Equipment.type_t)
  return static_cast< ::real::ConfigType >(type_t_);
}
inline void Item_Equipment::set_type_t(::real::ConfigType value) {
  assert(::real::ConfigType_IsValid(value));
  set_has_type_t();
  type_t_ = value;
  // @@protoc_insertion_point(field_set:real.Item_Equipment.type_t)
}

// optional .real.Item_CommonProp item_common_prop = 2;
inline bool Item_Equipment::has_item_common_prop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item_Equipment::set_has_item_common_prop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item_Equipment::clear_has_item_common_prop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item_Equipment::clear_item_common_prop() {
  if (item_common_prop_ != NULL) item_common_prop_->::real::Item_CommonProp::Clear();
  clear_has_item_common_prop();
}
inline const ::real::Item_CommonProp& Item_Equipment::item_common_prop() const {
  // @@protoc_insertion_point(field_get:real.Item_Equipment.item_common_prop)
  return item_common_prop_ != NULL ? *item_common_prop_ : *default_instance_->item_common_prop_;
}
inline ::real::Item_CommonProp* Item_Equipment::mutable_item_common_prop() {
  set_has_item_common_prop();
  if (item_common_prop_ == NULL) item_common_prop_ = new ::real::Item_CommonProp;
  // @@protoc_insertion_point(field_mutable:real.Item_Equipment.item_common_prop)
  return item_common_prop_;
}
inline ::real::Item_CommonProp* Item_Equipment::release_item_common_prop() {
  clear_has_item_common_prop();
  ::real::Item_CommonProp* temp = item_common_prop_;
  item_common_prop_ = NULL;
  return temp;
}
inline void Item_Equipment::set_allocated_item_common_prop(::real::Item_CommonProp* item_common_prop) {
  delete item_common_prop_;
  item_common_prop_ = item_common_prop;
  if (item_common_prop) {
    set_has_item_common_prop();
  } else {
    clear_has_item_common_prop();
  }
  // @@protoc_insertion_point(field_set_allocated:real.Item_Equipment.item_common_prop)
}

// optional .real.Item_Equipment.EuipType equip_type = 3;
inline bool Item_Equipment::has_equip_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item_Equipment::set_has_equip_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item_Equipment::clear_has_equip_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item_Equipment::clear_equip_type() {
  equip_type_ = 1;
  clear_has_equip_type();
}
inline ::real::Item_Equipment_EuipType Item_Equipment::equip_type() const {
  // @@protoc_insertion_point(field_get:real.Item_Equipment.equip_type)
  return static_cast< ::real::Item_Equipment_EuipType >(equip_type_);
}
inline void Item_Equipment::set_equip_type(::real::Item_Equipment_EuipType value) {
  assert(::real::Item_Equipment_EuipType_IsValid(value));
  set_has_equip_type();
  equip_type_ = value;
  // @@protoc_insertion_point(field_set:real.Item_Equipment.equip_type)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace real

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::real::CommonLimit_CommonLimitType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::real::CommonLimit_CommonLimitType>() {
  return ::real::CommonLimit_CommonLimitType_descriptor();
}
template <> struct is_proto_enum< ::real::CommonLimit_CoolDownType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::real::CommonLimit_CoolDownType>() {
  return ::real::CommonLimit_CoolDownType_descriptor();
}
template <> struct is_proto_enum< ::real::Harm_HarmType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::real::Harm_HarmType>() {
  return ::real::Harm_HarmType_descriptor();
}
template <> struct is_proto_enum< ::real::LevelUpCurve_Consume_CosumeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::real::LevelUpCurve_Consume_CosumeType>() {
  return ::real::LevelUpCurve_Consume_CosumeType_descriptor();
}
template <> struct is_proto_enum< ::real::Item_Potion_PotionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::real::Item_Potion_PotionType>() {
  return ::real::Item_Potion_PotionType_descriptor();
}
template <> struct is_proto_enum< ::real::Item_Equipment_EuipType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::real::Item_Equipment_EuipType>() {
  return ::real::Item_Equipment_EuipType_descriptor();
}
template <> struct is_proto_enum< ::real::ProfType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::real::ProfType>() {
  return ::real::ProfType_descriptor();
}
template <> struct is_proto_enum< ::real::InventoryType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::real::InventoryType>() {
  return ::real::InventoryType_descriptor();
}
template <> struct is_proto_enum< ::real::EntityType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::real::EntityType>() {
  return ::real::EntityType_descriptor();
}
template <> struct is_proto_enum< ::real::CampType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::real::CampType>() {
  return ::real::CampType_descriptor();
}
template <> struct is_proto_enum< ::real::Version> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::real::Version>() {
  return ::real::Version_descriptor();
}
template <> struct is_proto_enum< ::real::ConfigType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::real::ConfigType>() {
  return ::real::ConfigType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CommonConfig_2eproto__INCLUDED
